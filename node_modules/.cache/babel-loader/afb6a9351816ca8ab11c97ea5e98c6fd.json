{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport 'cross-fetch/polyfill';\nimport { TokenSigner, SECP256K1Client } from 'jsontokens';\nimport { makeUUID4, nextMonth, getGlobalObject } from '@stacks/common';\nimport { makeDIDFromAddress } from './dids';\nimport { encryptECIES, decryptECIES, makeECPrivateKey, publicKeyToAddress } from '@stacks/encryption';\nimport { DEFAULT_SCOPE } from './constants';\nconst VERSION = '1.3.1';\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI) {\n  let scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_SCOPE.slice();\n  let appDomain = arguments.length > 4 ? arguments[4] : undefined;\n  let expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  let extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  const getWindowOrigin = paramName => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location === null || location === void 0 ? void 0 : location.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = await encryptECIES(publicKey, Buffer.from(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\nexport async function makeAuthResponse(privateKey) {\n  let profile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let username = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let metadata = arguments.length > 3 ? arguments[3] : undefined;\n  let coreToken = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let appPrivateKey = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  let expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : nextMonth().getTime();\n  let transitPublicKey = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  let hubUrl = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  let blockstackAPIUrl = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  let associationToken = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToAddress(publicKey);\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n\n    additionalProperties = {\n      email: (metadata === null || metadata === void 0 ? void 0 : metadata.email) ? metadata.email : null,\n      profile_url: (metadata === null || metadata === void 0 ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {}\n\n  const payload = Object.assign({}, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    profile,\n    username,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}","map":{"version":3,"sources":["../../src/messages.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport 'cross-fetch/polyfill';\nimport { TokenSigner, SECP256K1Client } from 'jsontokens';\nimport { makeUUID4, nextMonth, getGlobalObject } from '@stacks/common';\nimport { makeDIDFromAddress } from './dids';\nimport { encryptECIES, decryptECIES, makeECPrivateKey, publicKeyToAddress, } from '@stacks/encryption';\nimport { DEFAULT_SCOPE } from './constants';\nconst VERSION = '1.3.1';\nexport function generateTransitKey() {\n    const transitKey = makeECPrivateKey();\n    return transitKey;\n}\nexport function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = DEFAULT_SCOPE.slice(), appDomain, expiresAt = nextMonth().getTime(), extraParams = {}) {\n    const getWindowOrigin = (paramName) => {\n        const location = getGlobalObject('location', {\n            throwIfUnavailable: true,\n            usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n        });\n        return location === null || location === void 0 ? void 0 : location.origin;\n    };\n    if (!redirectURI) {\n        redirectURI = `${getWindowOrigin('redirectURI')}/`;\n    }\n    if (!manifestURI) {\n        manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n    }\n    if (!appDomain) {\n        appDomain = getWindowOrigin('appDomain');\n    }\n    const payload = Object.assign({}, extraParams, {\n        jti: makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: null,\n        public_keys: [],\n        domain_name: appDomain,\n        manifest_uri: manifestURI,\n        redirect_uri: redirectURI,\n        version: VERSION,\n        do_not_include_profile: true,\n        supports_hub_url: true,\n        scopes,\n    });\n    const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n    payload.public_keys = [publicKey];\n    const address = publicKeyToAddress(publicKey);\n    payload.iss = makeDIDFromAddress(address);\n    const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n    const token = tokenSigner.sign(payload);\n    return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n    const encryptedObj = await encryptECIES(publicKey, Buffer.from(privateKey), true);\n    const encryptedJSON = JSON.stringify(encryptedObj);\n    return Buffer.from(encryptedJSON).toString('hex');\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n    const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n    const encryptedObj = JSON.parse(unhexedString);\n    const decrypted = await decryptECIES(privateKey, encryptedObj);\n    if (typeof decrypted !== 'string') {\n        throw new Error('Unable to correctly decrypt private key');\n    }\n    else {\n        return decrypted;\n    }\n}\nexport async function makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n    const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n    const address = publicKeyToAddress(publicKey);\n    let privateKeyPayload = appPrivateKey;\n    let coreTokenPayload = coreToken;\n    let additionalProperties = {};\n    if (appPrivateKey !== undefined && appPrivateKey !== null) {\n        if (transitPublicKey !== undefined && transitPublicKey !== null) {\n            privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n            if (coreToken !== undefined && coreToken !== null) {\n                coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n            }\n        }\n        additionalProperties = {\n            email: (metadata === null || metadata === void 0 ? void 0 : metadata.email) ? metadata.email : null,\n            profile_url: (metadata === null || metadata === void 0 ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,\n            hubUrl,\n            blockstackAPIUrl,\n            associationToken,\n            version: VERSION,\n        };\n    }\n    else {\n    }\n    const payload = Object.assign({}, {\n        jti: makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: makeDIDFromAddress(address),\n        private_key: privateKeyPayload,\n        public_keys: [publicKey],\n        profile,\n        username,\n        core_token: coreTokenPayload,\n    }, additionalProperties);\n    const tokenSigner = new TokenSigner('ES256k', privateKey);\n    return tokenSigner.sign(payload);\n}\n//# sourceMappingURL=messages.js.map"]},"metadata":{},"sourceType":"module"}