{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { sha256, sha512 } from 'sha.js';\nimport { serializeCV } from './clarity';\nimport RIPEMD160 from 'ripemd160-min';\nimport randombytes from 'randombytes';\nimport { deserializeCV } from './clarity';\nimport fetch from 'cross-fetch';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash/cloneDeep';\nimport { with0x } from '@stacks/common';\nexport { randombytes as randomBytes };\nexport class BufferArray {\n  constructor() {\n    this._value = [];\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  appendHexString(hexString) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer) {\n    return this._value.push(buffer);\n  }\n\n  appendByte(octet) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(\"Value \".concat(octet, \" is not a valid byte\"));\n    }\n\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer() {\n    return Buffer.concat(this.value);\n  }\n\n}\nexport const leftPadHex = hexString => hexString.length % 2 == 0 ? hexString : \"0\".concat(hexString);\nexport const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');\nexport const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');\nexport const intToHexString = function (integer) {\n  let lengthBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  return integer.toString(16).padStart(lengthBytes * 2, '0');\n};\nexport const hexStringToInt = hexString => parseInt(hexString, 16);\nexport const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? Buffer.from(string).length > maxLengthBytes : false;\nexport function cloneDeep(obj) {\n  return lodashCloneDeep(obj);\n}\nexport function omit(obj, prop) {\n  const clone = cloneDeep(obj);\n  delete clone[prop];\n  return clone;\n}\nexport class sha512_256 extends sha512 {\n  constructor() {\n    super();\n    Object.assign(this, {\n      _ah: 0x22312194,\n      _al: 0xfc2bf72c,\n      _bh: 0x9f555fa3,\n      _bl: 0xc84c64c2,\n      _ch: 0x2393b86b,\n      _cl: 0x6f53b151,\n      _dh: 0x96387719,\n      _dl: 0x5940eabd,\n      _eh: 0x96283ee2,\n      _el: 0xa88effe3,\n      _fh: 0xbe5e1e25,\n      _fl: 0x53863992,\n      _gh: 0x2b0199fc,\n      _gl: 0x2c85b8aa,\n      _hh: 0x0eb72ddc,\n      _hl: 0x81c52ca2\n    });\n  }\n\n  digest(encoding) {\n    const buff = super.digest().slice(0, 32);\n    return encoding ? buff.toString(encoding) : buff;\n  }\n\n}\nexport const txidFromData = data => new sha512_256().update(data).digest('hex');\nexport const hash160 = input => {\n  const sha256Result = new sha256().update(input).digest();\n  return Buffer.from(new RIPEMD160().update(sha256Result).digest());\n};\nexport const hashP2PKH = input => {\n  return hash160(input).toString('hex');\n};\nexport const hashP2SH = (numSigs, pubKeys) => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(80 + numSigs);\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  bufferArray.appendByte(80 + pubKeys.length);\n  bufferArray.appendByte(174);\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\nexport function isClarityName(name) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\nexport async function fetchPrivate(input, init) {\n  const defaultFetchOpts = {\n    referrer: 'no-referrer',\n    referrerPolicy: 'no-referrer'\n  };\n  const fetchOpts = Object.assign(defaultFetchOpts, init);\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\nexport function cvToHex(cv) {\n  const serialized = serializeCV(cv);\n  return \"0x\".concat(serialized.toString('hex'));\n}\nexport function hexToCV(hex) {\n  return deserializeCV(hex);\n}\nexport const parseReadOnlyResponse = response => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\nexport const validateStacksAddress = stacksAddress => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nexport const validateTxId = txid => {\n  if (txid === 'success') return true;\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { sha256, sha512 } from 'sha.js';\nimport { serializeCV } from './clarity';\nimport RIPEMD160 from 'ripemd160-min';\nimport randombytes from 'randombytes';\nimport { deserializeCV } from './clarity';\nimport fetch from 'cross-fetch';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash/cloneDeep';\nimport { with0x } from '@stacks/common';\nexport { randombytes as randomBytes };\nexport class BufferArray {\n    constructor() {\n        this._value = [];\n    }\n    get value() {\n        return this._value;\n    }\n    appendHexString(hexString) {\n        this.value.push(Buffer.from(hexString, 'hex'));\n    }\n    push(buffer) {\n        return this._value.push(buffer);\n    }\n    appendByte(octet) {\n        if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n            throw new Error(`Value ${octet} is not a valid byte`);\n        }\n        this.value.push(Buffer.from([octet]));\n    }\n    concatBuffer() {\n        return Buffer.concat(this.value);\n    }\n}\nexport const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;\nexport const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');\nexport const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');\nexport const intToHexString = (integer, lengthBytes = 8) => integer.toString(16).padStart(lengthBytes * 2, '0');\nexport const hexStringToInt = (hexString) => parseInt(hexString, 16);\nexport const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? Buffer.from(string).length > maxLengthBytes : false;\nexport function cloneDeep(obj) {\n    return lodashCloneDeep(obj);\n}\nexport function omit(obj, prop) {\n    const clone = cloneDeep(obj);\n    delete clone[prop];\n    return clone;\n}\nexport class sha512_256 extends sha512 {\n    constructor() {\n        super();\n        Object.assign(this, {\n            _ah: 0x22312194,\n            _al: 0xfc2bf72c,\n            _bh: 0x9f555fa3,\n            _bl: 0xc84c64c2,\n            _ch: 0x2393b86b,\n            _cl: 0x6f53b151,\n            _dh: 0x96387719,\n            _dl: 0x5940eabd,\n            _eh: 0x96283ee2,\n            _el: 0xa88effe3,\n            _fh: 0xbe5e1e25,\n            _fl: 0x53863992,\n            _gh: 0x2b0199fc,\n            _gl: 0x2c85b8aa,\n            _hh: 0x0eb72ddc,\n            _hl: 0x81c52ca2,\n        });\n    }\n    digest(encoding) {\n        const buff = super.digest().slice(0, 32);\n        return encoding ? buff.toString(encoding) : buff;\n    }\n}\nexport const txidFromData = (data) => new sha512_256().update(data).digest('hex');\nexport const hash160 = (input) => {\n    const sha256Result = new sha256().update(input).digest();\n    return Buffer.from(new RIPEMD160().update(sha256Result).digest());\n};\nexport const hashP2PKH = (input) => {\n    return hash160(input).toString('hex');\n};\nexport const hashP2SH = (numSigs, pubKeys) => {\n    if (numSigs > 15 || pubKeys.length > 15) {\n        throw Error('P2SH multisig address can only contain up to 15 public keys');\n    }\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(80 + numSigs);\n    pubKeys.forEach(pubKey => {\n        bufferArray.appendByte(pubKey.length);\n        bufferArray.push(pubKey);\n    });\n    bufferArray.appendByte(80 + pubKeys.length);\n    bufferArray.appendByte(174);\n    const redeemScript = bufferArray.concatBuffer();\n    const redeemScriptHash = hash160(redeemScript);\n    return redeemScriptHash.toString('hex');\n};\nexport function isClarityName(name) {\n    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n    return regex.test(name) && name.length < 128;\n}\nexport async function fetchPrivate(input, init) {\n    const defaultFetchOpts = {\n        referrer: 'no-referrer',\n        referrerPolicy: 'no-referrer',\n    };\n    const fetchOpts = Object.assign(defaultFetchOpts, init);\n    const fetchResult = await fetch(input, fetchOpts);\n    return fetchResult;\n}\nexport function cvToHex(cv) {\n    const serialized = serializeCV(cv);\n    return `0x${serialized.toString('hex')}`;\n}\nexport function hexToCV(hex) {\n    return deserializeCV(hex);\n}\nexport const parseReadOnlyResponse = (response) => {\n    if (response.okay) {\n        return hexToCV(response.result);\n    }\n    else {\n        throw new Error(response.cause);\n    }\n};\nexport const validateStacksAddress = (stacksAddress) => {\n    try {\n        c32addressDecode(stacksAddress);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexport const validateTxId = (txid) => {\n    if (txid === 'success')\n        return true;\n    const value = with0x(txid).toLowerCase();\n    if (value.length !== 66)\n        return false;\n    return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}