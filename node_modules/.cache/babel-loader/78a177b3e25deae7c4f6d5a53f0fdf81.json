{"ast":null,"code":"(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === \"object\") {\n    // Node/CommonJS\n    module.exports = factory();\n  } else {\n    // Browser globals\n    window.wNumb = factory();\n  }\n})(function () {\n  \"use strict\";\n\n  var FormatOptions = [\"decimals\", \"thousand\", \"mark\", \"prefix\", \"suffix\", \"encoder\", \"decoder\", \"negativeBefore\", \"negative\", \"edit\", \"undo\"]; // General\n  // Reverse a string\n\n  function strReverse(a) {\n    return a.split(\"\").reverse().join(\"\");\n  } // Check if a string starts with a specified prefix.\n\n\n  function strStartsWith(input, match) {\n    return input.substring(0, match.length) === match;\n  } // Check is a string ends in a specified suffix.\n\n\n  function strEndsWith(input, match) {\n    return input.slice(-1 * match.length) === match;\n  } // Throw an error if formatting options are incompatible.\n\n\n  function throwEqualError(F, a, b) {\n    if ((F[a] || F[b]) && F[a] === F[b]) {\n      throw new Error(a);\n    }\n  } // Check if a number is finite and not NaN\n\n\n  function isValidNumber(input) {\n    return typeof input === \"number\" && isFinite(input);\n  } // Provide rounding-accurate toFixed method.\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\n\n\n  function toFixed(value, exp) {\n    value = value.toString().split(\"e\");\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\n    value = value.toString().split(\"e\");\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\n  } // Formatting\n  // Accept a number as input, output formatted string.\n\n\n  function formatTo(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {\n    var originalInput = input,\n        inputIsNegative,\n        inputPieces,\n        inputBase,\n        inputDecimals = \"\",\n        output = \"\"; // Apply user encoder to the input.\n    // Expected outcome: number.\n\n    if (encoder) {\n      input = encoder(input);\n    } // Stop if no valid number was provided, the number is infinite or NaN.\n\n\n    if (!isValidNumber(input)) {\n      return false;\n    } // Rounding away decimals might cause a value of -0\n    // when using very small ranges. Remove those cases.\n\n\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\n      input = 0;\n    } // Formatting is done on absolute numbers,\n    // decorated by an optional negative symbol.\n\n\n    if (input < 0) {\n      inputIsNegative = true;\n      input = Math.abs(input);\n    } // Reduce the number of decimals to the specified option.\n\n\n    if (decimals !== false) {\n      input = toFixed(input, decimals);\n    } // Transform the number into a string, so it can be split.\n\n\n    input = input.toString(); // Break the number on the decimal separator.\n\n    if (input.indexOf(\".\") !== -1) {\n      inputPieces = input.split(\".\");\n      inputBase = inputPieces[0];\n\n      if (mark) {\n        inputDecimals = mark + inputPieces[1];\n      }\n    } else {\n      // If it isn't split, the entire number will do.\n      inputBase = input;\n    } // Group numbers in sets of three.\n\n\n    if (thousand) {\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\n    } // If the number is negative, prefix with negation symbol.\n\n\n    if (inputIsNegative && negativeBefore) {\n      output += negativeBefore;\n    } // Prefix the number\n\n\n    if (prefix) {\n      output += prefix;\n    } // Normal negative option comes after the prefix. Defaults to '-'.\n\n\n    if (inputIsNegative && negative) {\n      output += negative;\n    } // Append the actual number.\n\n\n    output += inputBase;\n    output += inputDecimals; // Apply the suffix.\n\n    if (suffix) {\n      output += suffix;\n    } // Run the output through a user-specified post-formatter.\n\n\n    if (edit) {\n      output = edit(output, originalInput);\n    } // All done.\n\n\n    return output;\n  } // Accept a sting as input, output decoded number.\n\n\n  function formatFrom(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {\n    var originalInput = input,\n        inputIsNegative,\n        output = \"\"; // User defined pre-decoder. Result must be a non empty string.\n\n    if (undo) {\n      input = undo(input);\n    } // Test the input. Can't be empty.\n\n\n    if (!input || typeof input !== \"string\") {\n      return false;\n    } // If the string starts with the negativeBefore value: remove it.\n    // Remember is was there, the number is negative.\n\n\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\n      input = input.replace(negativeBefore, \"\");\n      inputIsNegative = true;\n    } // Repeat the same procedure for the prefix.\n\n\n    if (prefix && strStartsWith(input, prefix)) {\n      input = input.replace(prefix, \"\");\n    } // And again for negative.\n\n\n    if (negative && strStartsWith(input, negative)) {\n      input = input.replace(negative, \"\");\n      inputIsNegative = true;\n    } // Remove the suffix.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\n\n\n    if (suffix && strEndsWith(input, suffix)) {\n      input = input.slice(0, -1 * suffix.length);\n    } // Remove the thousand grouping.\n\n\n    if (thousand) {\n      input = input.split(thousand).join(\"\");\n    } // Set the decimal separator back to period.\n\n\n    if (mark) {\n      input = input.replace(mark, \".\");\n    } // Prepend the negative symbol.\n\n\n    if (inputIsNegative) {\n      output += \"-\";\n    } // Add the number\n\n\n    output += input; // Trim all non-numeric characters (allow '.' and '-');\n\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\"); // The value contains no parse-able number.\n\n    if (output === \"\") {\n      return false;\n    } // Covert to number.\n\n\n    output = Number(output); // Run the user-specified post-decoder.\n\n    if (decoder) {\n      output = decoder(output);\n    } // Check is the output is valid, otherwise: return false.\n\n\n    if (!isValidNumber(output)) {\n      return false;\n    }\n\n    return output;\n  } // Framework\n  // Validate formatting options\n\n\n  function validate(inputOptions) {\n    var i,\n        optionName,\n        optionValue,\n        filteredOptions = {};\n\n    if (inputOptions[\"suffix\"] === undefined) {\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\n    }\n\n    for (i = 0; i < FormatOptions.length; i += 1) {\n      optionName = FormatOptions[i];\n      optionValue = inputOptions[optionName];\n\n      if (optionValue === undefined) {\n        // Only default if negativeBefore isn't set.\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\n          filteredOptions[optionName] = \"-\"; // Don't set a default for mark when 'thousand' is set.\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\n          filteredOptions[optionName] = \".\";\n        } else {\n          filteredOptions[optionName] = false;\n        } // Floating points in JS are stable up to 7 decimals.\n\n      } else if (optionName === \"decimals\") {\n        if (optionValue >= 0 && optionValue < 8) {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        } // These options, when provided, must be functions.\n\n      } else if (optionName === \"encoder\" || optionName === \"decoder\" || optionName === \"edit\" || optionName === \"undo\") {\n        if (typeof optionValue === \"function\") {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        } // Other options are strings.\n\n      } else {\n        if (typeof optionValue === \"string\") {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        }\n      }\n    } // Some values can't be extracted from a\n    // string if certain combinations are present.\n\n\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\n    return filteredOptions;\n  } // Pass all options as function arguments\n\n\n  function passAll(options, method, input) {\n    var i,\n        args = []; // Add all options in order of FormatOptions\n\n    for (i = 0; i < FormatOptions.length; i += 1) {\n      args.push(options[FormatOptions[i]]);\n    } // Append the input, then call the method, presenting all\n    // options as arguments.\n\n\n    args.push(input);\n    return method.apply(\"\", args);\n  }\n\n  function wNumb(options) {\n    if (!(this instanceof wNumb)) {\n      return new wNumb(options);\n    }\n\n    if (typeof options !== \"object\") {\n      return;\n    }\n\n    options = validate(options); // Call 'formatTo' with proper arguments.\n\n    this.to = function (input) {\n      return passAll(options, formatTo, input);\n    }; // Call 'formatFrom' with proper arguments.\n\n\n    this.from = function (input) {\n      return passAll(options, formatFrom, input);\n    };\n  }\n\n  return wNumb;\n});","map":{"version":3,"sources":["/Users/jvledesma/www-bitfari/node_modules/wnumb/wNumb.js"],"names":["factory","define","amd","exports","module","window","wNumb","FormatOptions","strReverse","a","split","reverse","join","strStartsWith","input","match","substring","length","strEndsWith","slice","throwEqualError","F","b","Error","isValidNumber","isFinite","toFixed","value","exp","toString","Math","round","formatTo","decimals","thousand","mark","prefix","suffix","encoder","decoder","negativeBefore","negative","edit","undo","originalInput","inputIsNegative","inputPieces","inputBase","inputDecimals","output","parseFloat","abs","indexOf","formatFrom","replace","Number","validate","inputOptions","i","optionName","optionValue","filteredOptions","undefined","passAll","options","method","args","push","apply","to","from"],"mappings":"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","sourcesContent":["(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof exports === \"object\") {\r\n    // Node/CommonJS\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals\r\n    window.wNumb = factory();\r\n  }\r\n})(function() {\r\n  \"use strict\";\r\n\r\n  var FormatOptions = [\r\n    \"decimals\",\r\n    \"thousand\",\r\n    \"mark\",\r\n    \"prefix\",\r\n    \"suffix\",\r\n    \"encoder\",\r\n    \"decoder\",\r\n    \"negativeBefore\",\r\n    \"negative\",\r\n    \"edit\",\r\n    \"undo\"\r\n  ];\r\n\r\n  // General\r\n\r\n  // Reverse a string\r\n  function strReverse(a) {\r\n    return a\r\n      .split(\"\")\r\n      .reverse()\r\n      .join(\"\");\r\n  }\r\n\r\n  // Check if a string starts with a specified prefix.\r\n  function strStartsWith(input, match) {\r\n    return input.substring(0, match.length) === match;\r\n  }\r\n\r\n  // Check is a string ends in a specified suffix.\r\n  function strEndsWith(input, match) {\r\n    return input.slice(-1 * match.length) === match;\r\n  }\r\n\r\n  // Throw an error if formatting options are incompatible.\r\n  function throwEqualError(F, a, b) {\r\n    if ((F[a] || F[b]) && F[a] === F[b]) {\r\n      throw new Error(a);\r\n    }\r\n  }\r\n\r\n  // Check if a number is finite and not NaN\r\n  function isValidNumber(input) {\r\n    return typeof input === \"number\" && isFinite(input);\r\n  }\r\n\r\n  // Provide rounding-accurate toFixed method.\r\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\r\n  function toFixed(value, exp) {\r\n    value = value.toString().split(\"e\");\r\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\r\n    value = value.toString().split(\"e\");\r\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\r\n  }\r\n\r\n  // Formatting\r\n\r\n  // Accept a number as input, output formatted string.\r\n  function formatTo(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      inputPieces,\r\n      inputBase,\r\n      inputDecimals = \"\",\r\n      output = \"\";\r\n\r\n    // Apply user encoder to the input.\r\n    // Expected outcome: number.\r\n    if (encoder) {\r\n      input = encoder(input);\r\n    }\r\n\r\n    // Stop if no valid number was provided, the number is infinite or NaN.\r\n    if (!isValidNumber(input)) {\r\n      return false;\r\n    }\r\n\r\n    // Rounding away decimals might cause a value of -0\r\n    // when using very small ranges. Remove those cases.\r\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\r\n      input = 0;\r\n    }\r\n\r\n    // Formatting is done on absolute numbers,\r\n    // decorated by an optional negative symbol.\r\n    if (input < 0) {\r\n      inputIsNegative = true;\r\n      input = Math.abs(input);\r\n    }\r\n\r\n    // Reduce the number of decimals to the specified option.\r\n    if (decimals !== false) {\r\n      input = toFixed(input, decimals);\r\n    }\r\n\r\n    // Transform the number into a string, so it can be split.\r\n    input = input.toString();\r\n\r\n    // Break the number on the decimal separator.\r\n    if (input.indexOf(\".\") !== -1) {\r\n      inputPieces = input.split(\".\");\r\n\r\n      inputBase = inputPieces[0];\r\n\r\n      if (mark) {\r\n        inputDecimals = mark + inputPieces[1];\r\n      }\r\n    } else {\r\n      // If it isn't split, the entire number will do.\r\n      inputBase = input;\r\n    }\r\n\r\n    // Group numbers in sets of three.\r\n    if (thousand) {\r\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\r\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\r\n    }\r\n\r\n    // If the number is negative, prefix with negation symbol.\r\n    if (inputIsNegative && negativeBefore) {\r\n      output += negativeBefore;\r\n    }\r\n\r\n    // Prefix the number\r\n    if (prefix) {\r\n      output += prefix;\r\n    }\r\n\r\n    // Normal negative option comes after the prefix. Defaults to '-'.\r\n    if (inputIsNegative && negative) {\r\n      output += negative;\r\n    }\r\n\r\n    // Append the actual number.\r\n    output += inputBase;\r\n    output += inputDecimals;\r\n\r\n    // Apply the suffix.\r\n    if (suffix) {\r\n      output += suffix;\r\n    }\r\n\r\n    // Run the output through a user-specified post-formatter.\r\n    if (edit) {\r\n      output = edit(output, originalInput);\r\n    }\r\n\r\n    // All done.\r\n    return output;\r\n  }\r\n\r\n  // Accept a sting as input, output decoded number.\r\n  function formatFrom(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      output = \"\";\r\n\r\n    // User defined pre-decoder. Result must be a non empty string.\r\n    if (undo) {\r\n      input = undo(input);\r\n    }\r\n\r\n    // Test the input. Can't be empty.\r\n    if (!input || typeof input !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    // If the string starts with the negativeBefore value: remove it.\r\n    // Remember is was there, the number is negative.\r\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\r\n      input = input.replace(negativeBefore, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Repeat the same procedure for the prefix.\r\n    if (prefix && strStartsWith(input, prefix)) {\r\n      input = input.replace(prefix, \"\");\r\n    }\r\n\r\n    // And again for negative.\r\n    if (negative && strStartsWith(input, negative)) {\r\n      input = input.replace(negative, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Remove the suffix.\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\r\n    if (suffix && strEndsWith(input, suffix)) {\r\n      input = input.slice(0, -1 * suffix.length);\r\n    }\r\n\r\n    // Remove the thousand grouping.\r\n    if (thousand) {\r\n      input = input.split(thousand).join(\"\");\r\n    }\r\n\r\n    // Set the decimal separator back to period.\r\n    if (mark) {\r\n      input = input.replace(mark, \".\");\r\n    }\r\n\r\n    // Prepend the negative symbol.\r\n    if (inputIsNegative) {\r\n      output += \"-\";\r\n    }\r\n\r\n    // Add the number\r\n    output += input;\r\n\r\n    // Trim all non-numeric characters (allow '.' and '-');\r\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\");\r\n\r\n    // The value contains no parse-able number.\r\n    if (output === \"\") {\r\n      return false;\r\n    }\r\n\r\n    // Covert to number.\r\n    output = Number(output);\r\n\r\n    // Run the user-specified post-decoder.\r\n    if (decoder) {\r\n      output = decoder(output);\r\n    }\r\n\r\n    // Check is the output is valid, otherwise: return false.\r\n    if (!isValidNumber(output)) {\r\n      return false;\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  // Framework\r\n\r\n  // Validate formatting options\r\n  function validate(inputOptions) {\r\n    var i,\r\n      optionName,\r\n      optionValue,\r\n      filteredOptions = {};\r\n\r\n    if (inputOptions[\"suffix\"] === undefined) {\r\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\r\n    }\r\n\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      optionName = FormatOptions[i];\r\n      optionValue = inputOptions[optionName];\r\n\r\n      if (optionValue === undefined) {\r\n        // Only default if negativeBefore isn't set.\r\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\r\n          filteredOptions[optionName] = \"-\";\r\n          // Don't set a default for mark when 'thousand' is set.\r\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\r\n          filteredOptions[optionName] = \".\";\r\n        } else {\r\n          filteredOptions[optionName] = false;\r\n        }\r\n\r\n        // Floating points in JS are stable up to 7 decimals.\r\n      } else if (optionName === \"decimals\") {\r\n        if (optionValue >= 0 && optionValue < 8) {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // These options, when provided, must be functions.\r\n      } else if (\r\n        optionName === \"encoder\" ||\r\n        optionName === \"decoder\" ||\r\n        optionName === \"edit\" ||\r\n        optionName === \"undo\"\r\n      ) {\r\n        if (typeof optionValue === \"function\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // Other options are strings.\r\n      } else {\r\n        if (typeof optionValue === \"string\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Some values can't be extracted from a\r\n    // string if certain combinations are present.\r\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\r\n\r\n    return filteredOptions;\r\n  }\r\n\r\n  // Pass all options as function arguments\r\n  function passAll(options, method, input) {\r\n    var i,\r\n      args = [];\r\n\r\n    // Add all options in order of FormatOptions\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      args.push(options[FormatOptions[i]]);\r\n    }\r\n\r\n    // Append the input, then call the method, presenting all\r\n    // options as arguments.\r\n    args.push(input);\r\n    return method.apply(\"\", args);\r\n  }\r\n\r\n  function wNumb(options) {\r\n    if (!(this instanceof wNumb)) {\r\n      return new wNumb(options);\r\n    }\r\n\r\n    if (typeof options !== \"object\") {\r\n      return;\r\n    }\r\n\r\n    options = validate(options);\r\n\r\n    // Call 'formatTo' with proper arguments.\r\n    this.to = function(input) {\r\n      return passAll(options, formatTo, input);\r\n    };\r\n\r\n    // Call 'formatFrom' with proper arguments.\r\n    this.from = function(input) {\r\n      return passAll(options, formatFrom, input);\r\n    };\r\n  }\r\n\r\n  return wNumb;\r\n});\r\n"]},"metadata":{},"sourceType":"script"}