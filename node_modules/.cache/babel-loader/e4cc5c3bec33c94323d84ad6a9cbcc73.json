{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64url_1 = require(\"base64url\");\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nconst sha256_1 = require(\"./cryptoClients/sha256\");\n\nfunction createSigningInput(payload, header) {\n  const tokenParts = []; // add in the header\n\n  const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader); // add in the payload\n\n  const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload); // prepare the message\n\n  const signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  const header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nclass TokenSigner {\n  constructor(signingAlgorithm, rawPrivateKey) {\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  header() {\n    let header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultHeader = {\n      typ: this.tokenType,\n      alg: this.cryptoClient.algorithmName\n    };\n    return Object.assign({}, defaultHeader, header);\n  }\n\n  sign(payload) {\n    let expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // generate the token header\n    const header = this.header(customHeader); // prepare the message to be signed\n\n    const signingInput = createSigningInput(payload, header);\n    const signingInputHash = sha256_1.hashSha256(signingInput);\n    return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n  }\n\n  signAsync(payload) {\n    let expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      // generate the token header\n      const header = this.header(customHeader); // prepare the message to be signed\n\n      const signingInput = createSigningInput(payload, header);\n      const signingInputHash = yield sha256_1.hashSha256Async(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    });\n  }\n\n  createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n    // sign the message and add in the signature\n    const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n    if (expanded) {\n      const signedToken = {\n        'header': [base64url_1.default.encode(JSON.stringify(header))],\n        'payload': JSON.stringify(payload),\n        'signature': [signature]\n      };\n      return signedToken;\n    } else {\n      return [signingInput, signature].join('.');\n    }\n  }\n\n}\n\nexports.TokenSigner = TokenSigner;","map":{"version":3,"sources":["signer.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = require(\"base64url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nfunction createSigningInput(payload, header) {\n    const tokenParts = [];\n    // add in the header\n    const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n    tokenParts.push(encodedHeader);\n    // add in the payload\n    const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n    tokenParts.push(encodedPayload);\n    // prepare the message\n    const signingInput = tokenParts.join('.');\n    // return the signing input\n    return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n    const header = { typ: 'JWT', alg: 'none' };\n    return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n    constructor(signingAlgorithm, rawPrivateKey) {\n        if (!(signingAlgorithm && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw new Error('signing algorithm parameter must be a string');\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw new Error('invalid signing algorithm');\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPrivateKey = rawPrivateKey;\n    }\n    header(header = {}) {\n        const defaultHeader = { typ: this.tokenType,\n            alg: this.cryptoClient.algorithmName };\n        return Object.assign({}, defaultHeader, header);\n    }\n    sign(payload, expanded = false, customHeader = {}) {\n        // generate the token header\n        const header = this.header(customHeader);\n        // prepare the message to be signed\n        const signingInput = createSigningInput(payload, header);\n        const signingInputHash = sha256_1.hashSha256(signingInput);\n        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    }\n    signAsync(payload, expanded = false, customHeader = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // generate the token header\n            const header = this.header(customHeader);\n            // prepare the message to be signed\n            const signingInput = createSigningInput(payload, header);\n            const signingInputHash = yield sha256_1.hashSha256Async(signingInput);\n            return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n        });\n    }\n    createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n        // sign the message and add in the signature\n        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n        if (expanded) {\n            const signedToken = {\n                'header': [\n                    base64url_1.default.encode(JSON.stringify(header))\n                ],\n                'payload': JSON.stringify(payload),\n                'signature': [\n                    signature\n                ]\n            };\n            return signedToken;\n        }\n        else {\n            return [signingInput, signature].join('.');\n        }\n    }\n}\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}