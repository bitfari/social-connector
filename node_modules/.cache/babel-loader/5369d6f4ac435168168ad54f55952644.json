{"ast":null,"code":"import _asyncToGenerator from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/jvledesma/Downloads/vuexy-admin-v8.0.0/react-version/Bootstrap5/full-version/node_modules/@babel/runtime/regenerator/index.js\";\nimport { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent as _decryptContent, encryptContent as _encryptContent, hexStringToECPair } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, fetchPrivate, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants';\nimport * as queryString from 'query-string';\nimport { StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport var UserSession = /*#__PURE__*/function () {\n  function UserSession(options) {\n    _classCallCheck(this, UserSession);\n\n    var runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  _createClass(UserSession, [{\n    key: \"makeAuthRequest\",\n    value: function makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain) {\n      var expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextHour().getTime();\n      var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n      var appConfig = this.appConfig;\n\n      if (!appConfig) {\n        throw new InvalidStateError('Missing AppConfig');\n      }\n\n      transitKey = transitKey || this.generateAndStoreTransitKey();\n      redirectURI = redirectURI || appConfig.redirectURI();\n      manifestURI = manifestURI || appConfig.manifestURI();\n      scopes = scopes || appConfig.scopes;\n      appDomain = appDomain || appConfig.appDomain;\n      return authMessages.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n    }\n  }, {\n    key: \"generateAndStoreTransitKey\",\n    value: function generateAndStoreTransitKey() {\n      var sessionData = this.store.getSessionData();\n      var transitKey = authMessages.generateTransitKey();\n      sessionData.transitKey = transitKey;\n      this.store.setSessionData(sessionData);\n      return transitKey;\n    }\n  }, {\n    key: \"getAuthResponseToken\",\n    value: function getAuthResponseToken() {\n      var _a;\n\n      var search = (_a = getGlobalObject('location', {\n        throwIfUnavailable: true,\n        usageDesc: 'getAuthResponseToken'\n      })) === null || _a === void 0 ? void 0 : _a.search;\n\n      if (search) {\n        var queryDict = queryString.parse(search);\n        return queryDict.authResponse ? queryDict.authResponse : '';\n      }\n\n      return '';\n    }\n  }, {\n    key: \"isSignInPending\",\n    value: function isSignInPending() {\n      try {\n        var isProtocolEcho = protocolEchoReplyDetection();\n\n        if (isProtocolEcho) {\n          Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n          return true;\n        }\n      } catch (error) {\n        Logger.error(\"Error checking for protocol echo reply isSignInPending: \".concat(error));\n      }\n\n      return !!this.getAuthResponseToken();\n    }\n  }, {\n    key: \"isUserSignedIn\",\n    value: function isUserSignedIn() {\n      return !!this.store.getSessionData().userData;\n    }\n  }, {\n    key: \"handlePendingSignIn\",\n    value: function () {\n      var _handlePendingSignIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var authResponseToken,\n            sessionData,\n            transitKey,\n            coreNode,\n            network,\n            tokenPayload,\n            nameLookupURL,\n            fallbackLookupURLs,\n            isValid,\n            appPrivateKey,\n            coreSessionToken,\n            hubUrl,\n            gaiaAssociationToken,\n            userData,\n            profileURL,\n            response,\n            responseText,\n            wrappedProfile,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                authResponseToken = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.getAuthResponseToken();\n                sessionData = this.store.getSessionData();\n\n                if (!sessionData.userData) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new LoginFailedError('Existing user session found.');\n\n              case 4:\n                transitKey = this.store.getSessionData().transitKey;\n                coreNode = this.appConfig && this.appConfig.coreNode;\n\n                if (!coreNode) {\n                  network = new StacksMainnet();\n                  coreNode = network.bnsLookupUrl;\n                }\n\n                tokenPayload = decodeToken(authResponseToken).payload;\n\n                if (!(typeof tokenPayload === 'string')) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error('Unexpected token payload type of string');\n\n              case 10:\n                nameLookupURL = \"\".concat(coreNode).concat(NAME_LOOKUP_PATH);\n                fallbackLookupURLs = [\"https://stacks-node-api.stacks.co\".concat(NAME_LOOKUP_PATH), \"https://registrar.stacks.co\".concat(NAME_LOOKUP_PATH)].filter(function (url) {\n                  return url !== nameLookupURL;\n                });\n                _context.next = 14;\n                return verifyAuthResponse(authResponseToken, nameLookupURL, fallbackLookupURLs);\n\n              case 14:\n                isValid = _context.sent;\n\n                if (isValid) {\n                  _context.next = 17;\n                  break;\n                }\n\n                throw new LoginFailedError('Invalid authentication response.');\n\n              case 17:\n                appPrivateKey = tokenPayload.private_key;\n                coreSessionToken = tokenPayload.core_token;\n\n                if (!isLaterVersion(tokenPayload.version, '1.1.0')) {\n                  _context.next = 51;\n                  break;\n                }\n\n                if (!(transitKey !== undefined && transitKey != null)) {\n                  _context.next = 50;\n                  break;\n                }\n\n                if (!(tokenPayload.private_key !== undefined && tokenPayload.private_key !== null)) {\n                  _context.next = 38;\n                  break;\n                }\n\n                _context.prev = 22;\n                _context.next = 25;\n                return authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key);\n\n              case 25:\n                appPrivateKey = _context.sent;\n                _context.next = 38;\n                break;\n\n              case 28:\n                _context.prev = 28;\n                _context.t0 = _context[\"catch\"](22);\n                Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n                _context.prev = 31;\n                hexStringToECPair(tokenPayload.private_key);\n                _context.next = 38;\n                break;\n\n              case 35:\n                _context.prev = 35;\n                _context.t1 = _context[\"catch\"](31);\n                throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n\n              case 38:\n                if (!(coreSessionToken !== undefined && coreSessionToken !== null)) {\n                  _context.next = 48;\n                  break;\n                }\n\n                _context.prev = 39;\n                _context.next = 42;\n                return authMessages.decryptPrivateKey(transitKey, coreSessionToken);\n\n              case 42:\n                coreSessionToken = _context.sent;\n                _context.next = 48;\n                break;\n\n              case 45:\n                _context.prev = 45;\n                _context.t2 = _context[\"catch\"](39);\n                Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n\n              case 48:\n                _context.next = 51;\n                break;\n\n              case 50:\n                throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n\n              case 51:\n                hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n\n                if (isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n                  hubUrl = tokenPayload.hubUrl;\n                }\n\n                if (isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n                  gaiaAssociationToken = tokenPayload.associationToken;\n                }\n\n                userData = {\n                  username: tokenPayload.username,\n                  profile: tokenPayload.profile,\n                  email: tokenPayload.email,\n                  decentralizedID: tokenPayload.iss,\n                  identityAddress: getAddressFromDID(tokenPayload.iss),\n                  appPrivateKey: appPrivateKey,\n                  coreSessionToken: coreSessionToken,\n                  authResponseToken: authResponseToken,\n                  hubUrl: hubUrl,\n                  coreNode: tokenPayload.blockstackAPIUrl,\n                  gaiaAssociationToken: gaiaAssociationToken\n                };\n                profileURL = tokenPayload.profile_url;\n\n                if (!(!userData.profile && profileURL)) {\n                  _context.next = 71;\n                  break;\n                }\n\n                _context.next = 59;\n                return fetchPrivate(profileURL);\n\n              case 59:\n                response = _context.sent;\n\n                if (response.ok) {\n                  _context.next = 64;\n                  break;\n                }\n\n                userData.profile = Object.assign({}, DEFAULT_PROFILE);\n                _context.next = 69;\n                break;\n\n              case 64:\n                _context.next = 66;\n                return response.text();\n\n              case 66:\n                responseText = _context.sent;\n                wrappedProfile = JSON.parse(responseText);\n                userData.profile = extractProfile(wrappedProfile[0].token);\n\n              case 69:\n                _context.next = 72;\n                break;\n\n              case 71:\n                userData.profile = tokenPayload.profile;\n\n              case 72:\n                sessionData.userData = userData;\n                this.store.setSessionData(sessionData);\n                return _context.abrupt(\"return\", userData);\n\n              case 75:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[22, 28], [31, 35], [39, 45]]);\n      }));\n\n      function handlePendingSignIn() {\n        return _handlePendingSignIn.apply(this, arguments);\n      }\n\n      return handlePendingSignIn;\n    }()\n  }, {\n    key: \"loadUserData\",\n    value: function loadUserData() {\n      var userData = this.store.getSessionData().userData;\n\n      if (!userData) {\n        throw new InvalidStateError('No user data found. Did the user sign in?');\n      }\n\n      return userData;\n    }\n  }, {\n    key: \"encryptContent\",\n    value: function encryptContent(content, options) {\n      var opts = Object.assign({}, options);\n\n      if (!opts.privateKey) {\n        opts.privateKey = this.loadUserData().appPrivateKey;\n      }\n\n      return _encryptContent(content, opts);\n    }\n  }, {\n    key: \"decryptContent\",\n    value: function decryptContent(content, options) {\n      var opts = Object.assign({}, options);\n\n      if (!opts.privateKey) {\n        opts.privateKey = this.loadUserData().appPrivateKey;\n      }\n\n      return _decryptContent(content, opts);\n    }\n  }, {\n    key: \"signUserOut\",\n    value: function signUserOut(redirectURL) {\n      this.store.deleteSessionData();\n\n      if (redirectURL) {\n        if (typeof location !== 'undefined' && location.href) {\n          location.href = redirectURL;\n        }\n      }\n    }\n  }]);\n\n  return UserSession;\n}();","map":{"version":3,"sources":["../../src/userSession.ts"],"names":[],"mappings":";;;;AAEA,SAAS,SAAT,QAA0B,aAA1B;AAEA,SAAS,iBAAT,EAA4B,iBAA5B,QAAuE,gBAAvE;AACA,SAAS,WAAT,QAA4B,YAA5B;AACA,SAAS,kBAAT,QAAmC,gBAAnC;AACA,OAAO,KAAK,YAAZ,MAA8B,YAA9B;AACA,SACE,cAAc,IAAd,eADF,EAEE,cAAc,IAAd,eAFF,EAIE,iBAJF,QAKO,oBALP;AAMA,SAAS,iBAAT,QAAkC,QAAlC;AACA,SACE,+BADF,EAEE,YAFF,EAGE,eAHF,EAIE,iBAJF,EAKE,cALF,EAME,MANF,EAOE,gBAPF,EAQE,qBARF,EASE,QATF,QAUO,gBAVP;AAWA,SAAS,cAAT,QAA+B,iBAA/B;AACA,SAAoB,eAApB,EAAqC,gBAArC,QAA6D,aAA7D;AACA,OAAO,KAAK,WAAZ,MAA6B,cAA7B;AAEA,SAAS,aAAT,QAA8B,iBAA9B;AACA,SAAS,0BAAT,QAA2C,yBAA3C;AAgBA,WAAa,WAAb;AAUE,uBAAY,OAAZ,EAIC;AAAA;;AACC,QAAI,gBAAgB,GAAG,IAAvB;;AAEA,QAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,OAAO,IAAP,KAAgB,WAArD,EAAkE;AAEhE,MAAA,gBAAgB,GAAG,KAAnB;AACD;;AAED,QAAI,OAAO,IAAI,OAAO,CAAC,SAAvB,EAAkC;AAChC,WAAK,SAAL,GAAiB,OAAO,CAAC,SAAzB;AACD,KAFD,MAEO,IAAI,gBAAJ,EAAsB;AAC3B,WAAK,SAAL,GAAiB,IAAI,SAAJ,EAAjB;AACD,KAFM,MAEA;AACL,YAAM,IAAI,qBAAJ,CAA0B,uCAA1B,CAAN;AACD;;AAED,QAAI,OAAO,IAAI,OAAO,CAAC,YAAvB,EAAqC;AACnC,WAAK,KAAL,GAAa,OAAO,CAAC,YAArB;AACD,KAFD,MAEO,IAAI,gBAAJ,EAAsB;AAC3B,UAAI,OAAJ,EAAa;AACX,aAAK,KAAL,GAAa,IAAI,iBAAJ,CAAsB,OAAO,CAAC,cAA9B,CAAb;AACD,OAFD,MAEO;AACL,aAAK,KAAL,GAAa,IAAI,iBAAJ,EAAb;AACD;AACF,KANM,MAMA,IAAI,OAAJ,EAAa;AAClB,WAAK,KAAL,GAAa,IAAI,iBAAJ,CAAsB,OAAO,CAAC,cAA9B,CAAb;AACD,KAFM,MAEA;AACL,WAAK,KAAL,GAAa,IAAI,iBAAJ,EAAb;AACD;AACF;;AA3CH;AAAA;AAAA,WAkEE,yBACE,UADF,EAEE,WAFF,EAGE,WAHF,EAIE,MAJF,EAKE,SALF,EAOuB;AAAA,UADrB,SACqB,uEADD,QAAQ,GAAG,OAAX,EACC;AAAA,UAArB,WAAqB,uEAAF,EAAE;AAErB,UAAM,SAAS,GAAG,KAAK,SAAvB;;AACA,UAAI,CAAC,SAAL,EAAgB;AACd,cAAM,IAAI,iBAAJ,CAAsB,mBAAtB,CAAN;AACD;;AACD,MAAA,UAAU,GAAG,UAAU,IAAI,KAAK,0BAAL,EAA3B;AACA,MAAA,WAAW,GAAG,WAAW,IAAI,SAAS,CAAC,WAAV,EAA7B;AACA,MAAA,WAAW,GAAG,WAAW,IAAI,SAAS,CAAC,WAAV,EAA7B;AACA,MAAA,MAAM,GAAG,MAAM,IAAI,SAAS,CAAC,MAA7B;AACA,MAAA,SAAS,GAAG,SAAS,IAAI,SAAS,CAAC,SAAnC;AACA,aAAO,YAAY,CAAC,eAAb,CACL,UADK,EAEL,WAFK,EAGL,WAHK,EAIL,MAJK,EAKL,SALK,EAML,SANK,EAOL,WAPK,CAAP;AASD;AA7FH;AAAA;AAAA,WAuGE,sCAA0B;AACxB,UAAM,WAAW,GAAG,KAAK,KAAL,CAAW,cAAX,EAApB;AACA,UAAM,UAAU,GAAG,YAAY,CAAC,kBAAb,EAAnB;AACA,MAAA,WAAW,CAAC,UAAZ,GAAyB,UAAzB;AACA,WAAK,KAAL,CAAW,cAAX,CAA0B,WAA1B;AACA,aAAO,UAAP;AACD;AA7GH;AAAA;AAAA,WAmHE,gCAAoB;;;AAClB,UAAM,MAAM,GAAG,CAAA,EAAA,GAAA,eAAe,CAAC,UAAD,EAAa;AACzC,QAAA,kBAAkB,EAAE,IADqB;AAEzC,QAAA,SAAS,EAAE;AAF8B,OAAb,CAAf,MAGb,IAHa,IAGb,EAAA,KAAA,KAAA,CAHa,GAGb,KAAA,CAHa,GAGb,EAAA,CAAE,MAHJ;;AAIA,UAAI,MAAJ,EAAY;AACV,YAAM,SAAS,GAAG,WAAW,CAAC,KAAZ,CAAkB,MAAlB,CAAlB;AACA,eAAO,SAAS,CAAC,YAAV,GAA0B,SAAS,CAAC,YAApC,GAA8D,EAArE;AACD;;AACD,aAAO,EAAP;AACD;AA7HH;AAAA;AAAA,WAuIE,2BAAe;AACb,UAAI;AACF,YAAM,cAAc,GAAG,0BAA0B,EAAjD;;AACA,YAAI,cAAJ,EAAoB;AAClB,UAAA,MAAM,CAAC,IAAP,CACE,sFADF;AAGA,iBAAO,IAAP;AACD;AACF,OARD,CAQE,OAAO,KAAP,EAAc;AACd,QAAA,MAAM,CAAC,KAAP,mEAAwE,KAAxE;AACD;;AAED,aAAO,CAAC,CAAC,KAAK,oBAAL,EAAT;AACD;AArJH;AAAA;AAAA,WA4JE,0BAAc;AACZ,aAAO,CAAC,CAAC,KAAK,KAAL,CAAW,cAAX,GAA4B,QAArC;AACD;AA9JH;AAAA;AAAA;AAAA,0FAwKE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,gBAAA,iBADF,2DAC8B,KAAK,oBAAL,EAD9B;AAGQ,gBAAA,WAHR,GAGsB,KAAK,KAAL,CAAW,cAAX,EAHtB;;AAAA,qBAKM,WAAW,CAAC,QALlB;AAAA;AAAA;AAAA;;AAAA,sBAMU,IAAI,gBAAJ,CAAqB,8BAArB,CANV;;AAAA;AASQ,gBAAA,UATR,GASqB,KAAK,KAAL,CAAW,cAAX,GAA4B,UATjD;AAYM,gBAAA,QAZN,GAYiB,KAAK,SAAL,IAAkB,KAAK,SAAL,CAAe,QAZlD;;AAaE,oBAAI,CAAC,QAAL,EAAe;AACP,kBAAA,OADO,GACG,IAAI,aAAJ,EADH;AAEb,kBAAA,QAAQ,GAAG,OAAO,CAAC,YAAnB;AACD;;AAEK,gBAAA,YAlBR,GAkBuB,WAAW,CAAC,iBAAD,CAAX,CAA+B,OAlBtD;;AAAA,sBAoBM,OAAO,YAAP,KAAwB,QApB9B;AAAA;AAAA;AAAA;;AAAA,sBAqBU,IAAI,KAAJ,CAAU,yCAAV,CArBV;;AAAA;AAqCQ,gBAAA,aArCR,aAqC2B,QArC3B,SAqCsC,gBArCtC;AAuCQ,gBAAA,kBAvCR,GAuC6B,4CACW,gBADX,wCAEK,gBAFL,GAGzB,MAHyB,CAGlB,UAAA,GAAG;AAAA,yBAAI,GAAG,KAAK,aAAZ;AAAA,iBAHe,CAvC7B;AAAA;AAAA,uBA4CwB,kBAAkB,CAAC,iBAAD,EAAoB,aAApB,EAAmC,kBAAnC,CA5C1C;;AAAA;AA4CQ,gBAAA,OA5CR;;AAAA,oBA6CO,OA7CP;AAAA;AAAA;AAAA;;AAAA,sBA8CU,IAAI,gBAAJ,CAAqB,kCAArB,CA9CV;;AAAA;AAkDM,gBAAA,aAlDN,GAkD8B,YAAY,CAAC,WAlD3C;AAmDM,gBAAA,gBAnDN,GAmDiC,YAAY,CAAC,UAnD9C;;AAAA,qBAoDM,cAAc,CAAC,YAAY,CAAC,OAAd,EAAiC,OAAjC,CApDpB;AAAA;AAAA;AAAA;;AAAA,sBAqDQ,UAAU,KAAK,SAAf,IAA4B,UAAU,IAAI,IArDlD;AAAA;AAAA;AAAA;;AAAA,sBAsDU,YAAY,CAAC,WAAb,KAA6B,SAA7B,IAA0C,YAAY,CAAC,WAAb,KAA6B,IAtDjF;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,uBAwDiC,YAAY,CAAC,iBAAb,CACrB,UADqB,EAErB,YAAY,CAAC,WAFQ,CAxDjC;;AAAA;AAwDU,gBAAA,aAxDV;AAAA;AAAA;;AAAA;AAAA;AAAA;AA6DU,gBAAA,MAAM,CAAC,IAAP,CAAY,8DAAZ;AA7DV;AA+DY,gBAAA,iBAAiB,CAAC,YAAY,CAAC,WAAd,CAAjB;AA/DZ;AAAA;;AAAA;AAAA;AAAA;AAAA,sBAiEkB,IAAI,gBAAJ,CACJ,mDACE,iDAFE,CAjElB;;AAAA;AAAA,sBAwEU,gBAAgB,KAAK,SAArB,IAAkC,gBAAgB,KAAK,IAxEjE;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,uBA0EoC,YAAY,CAAC,iBAAb,CACxB,UADwB,EAExB,gBAFwB,CA1EpC;;AAAA;AA0EU,gBAAA,gBA1EV;AAAA;AAAA;;AAAA;AAAA;AAAA;AA+EU,gBAAA,MAAM,CAAC,IAAP,CAAY,iEAAZ;;AA/EV;AAAA;AAAA;;AAAA;AAAA,sBAmFY,IAAI,gBAAJ,CACJ,0DAA0D,uBADtD,CAnFZ;;AAAA;AAwFM,gBAAA,MAxFN,GAwFe,+BAxFf;;AA0FE,oBACE,cAAc,CAAC,YAAY,CAAC,OAAd,EAAiC,OAAjC,CAAd,IACA,YAAY,CAAC,MAAb,KAAwB,IADxB,IAEA,YAAY,CAAC,MAAb,KAAwB,SAH1B,EAIE;AACA,kBAAA,MAAM,GAAG,YAAY,CAAC,MAAtB;AACD;;AACD,oBACE,cAAc,CAAC,YAAY,CAAC,OAAd,EAAiC,OAAjC,CAAd,IACA,YAAY,CAAC,gBAAb,KAAkC,IADlC,IAEA,YAAY,CAAC,gBAAb,KAAkC,SAHpC,EAIE;AACA,kBAAA,oBAAoB,GAAG,YAAY,CAAC,gBAApC;AACD;;AAEK,gBAAA,QAzGR,GAyG6B;AACzB,kBAAA,QAAQ,EAAE,YAAY,CAAC,QADE;AAEzB,kBAAA,OAAO,EAAE,YAAY,CAAC,OAFG;AAGzB,kBAAA,KAAK,EAAE,YAAY,CAAC,KAHK;AAIzB,kBAAA,eAAe,EAAE,YAAY,CAAC,GAJL;AAKzB,kBAAA,eAAe,EAAE,iBAAiB,CAAC,YAAY,CAAC,GAAd,CALT;AAMzB,kBAAA,aAAa,EAAb,aANyB;AAOzB,kBAAA,gBAAgB,EAAhB,gBAPyB;AAQzB,kBAAA,iBAAiB,EAAjB,iBARyB;AASzB,kBAAA,MAAM,EAAN,MATyB;AAUzB,kBAAA,QAAQ,EAAE,YAAY,CAAC,gBAVE;AAYzB,kBAAA,oBAAoB,EAApB;AAZyB,iBAzG7B;AAuHQ,gBAAA,UAvHR,GAuHqB,YAAY,CAAC,WAvHlC;;AAAA,sBAwHM,CAAC,QAAQ,CAAC,OAAV,IAAqB,UAxH3B;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAyH2B,YAAY,CAAC,UAAD,CAzHvC;;AAAA;AAyHU,gBAAA,QAzHV;;AAAA,oBA0HS,QAAQ,CAAC,EA1HlB;AAAA;AAAA;AAAA;;AA4HM,gBAAA,QAAQ,CAAC,OAAT,GAAmB,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,eAAlB,CAAnB;AA5HN;AAAA;;AAAA;AAAA;AAAA,uBA8HiC,QAAQ,CAAC,IAAT,EA9HjC;;AAAA;AA8HY,gBAAA,YA9HZ;AA+HY,gBAAA,cA/HZ,GA+H6B,IAAI,CAAC,KAAL,CAAW,YAAX,CA/H7B;AAgIM,gBAAA,QAAQ,CAAC,OAAT,GAAmB,cAAc,CAAC,cAAc,CAAC,CAAD,CAAd,CAAkB,KAAnB,CAAjC;;AAhIN;AAAA;AAAA;;AAAA;AAmII,gBAAA,QAAQ,CAAC,OAAT,GAAmB,YAAY,CAAC,OAAhC;;AAnIJ;AAsIE,gBAAA,WAAW,CAAC,QAAZ,GAAuB,QAAvB;AACA,qBAAK,KAAL,CAAW,cAAX,CAA0B,WAA1B;AAvIF,iDAyIS,QAzIT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAxKF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WAyTE,wBAAY;AACV,UAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,cAAX,GAA4B,QAA7C;;AACA,UAAI,CAAC,QAAL,EAAe;AACb,cAAM,IAAI,iBAAJ,CAAsB,2CAAtB,CAAN;AACD;;AACD,aAAO,QAAP;AACD;AA/TH;AAAA;AAAA,WA0UE,wBAAe,OAAf,EAAyC,OAAzC,EAAwE;AACtE,UAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAb;;AACA,UAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AACpB,QAAA,IAAI,CAAC,UAAL,GAAkB,KAAK,YAAL,GAAoB,aAAtC;AACD;;AACD,aAAO,eAAc,CAAC,OAAD,EAAU,IAAV,CAArB;AACD;AAhVH;AAAA;AAAA,WA2VE,wBAAe,OAAf,EAAgC,OAAhC,EAAiE;AAC/D,UAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAb;;AACA,UAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AACpB,QAAA,IAAI,CAAC,UAAL,GAAkB,KAAK,YAAL,GAAoB,aAAtC;AACD;;AACD,aAAO,eAAc,CAAC,OAAD,EAAU,IAAV,CAArB;AACD;AAjWH;AAAA;AAAA,WA0WE,qBACE,WADF,EACsB;AAIpB,WAAK,KAAL,CAAW,iBAAX;;AACA,UAAI,WAAJ,EAAiB;AACf,YAAI,OAAO,QAAP,KAAoB,WAApB,IAAmC,QAAQ,CAAC,IAAhD,EAAsD;AACpD,UAAA,QAAQ,CAAC,IAAT,GAAgB,WAAhB;AACD;AAQF;AACF;AA5XH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["import { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent, encryptContent, hexStringToECPair, } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, fetchPrivate, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour, } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants';\nimport * as queryString from 'query-string';\nimport { StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport class UserSession {\n    constructor(options) {\n        let runningInBrowser = true;\n        if (typeof window === 'undefined' && typeof self === 'undefined') {\n            runningInBrowser = false;\n        }\n        if (options && options.appConfig) {\n            this.appConfig = options.appConfig;\n        }\n        else if (runningInBrowser) {\n            this.appConfig = new AppConfig();\n        }\n        else {\n            throw new MissingParameterError('You need to specify options.appConfig');\n        }\n        if (options && options.sessionStore) {\n            this.store = options.sessionStore;\n        }\n        else if (runningInBrowser) {\n            if (options) {\n                this.store = new LocalStorageStore(options.sessionOptions);\n            }\n            else {\n                this.store = new LocalStorageStore();\n            }\n        }\n        else if (options) {\n            this.store = new InstanceDataStore(options.sessionOptions);\n        }\n        else {\n            this.store = new InstanceDataStore();\n        }\n    }\n    makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = nextHour().getTime(), extraParams = {}) {\n        const appConfig = this.appConfig;\n        if (!appConfig) {\n            throw new InvalidStateError('Missing AppConfig');\n        }\n        transitKey = transitKey || this.generateAndStoreTransitKey();\n        redirectURI = redirectURI || appConfig.redirectURI();\n        manifestURI = manifestURI || appConfig.manifestURI();\n        scopes = scopes || appConfig.scopes;\n        appDomain = appDomain || appConfig.appDomain;\n        return authMessages.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n    }\n    generateAndStoreTransitKey() {\n        const sessionData = this.store.getSessionData();\n        const transitKey = authMessages.generateTransitKey();\n        sessionData.transitKey = transitKey;\n        this.store.setSessionData(sessionData);\n        return transitKey;\n    }\n    getAuthResponseToken() {\n        var _a;\n        const search = (_a = getGlobalObject('location', {\n            throwIfUnavailable: true,\n            usageDesc: 'getAuthResponseToken',\n        })) === null || _a === void 0 ? void 0 : _a.search;\n        if (search) {\n            const queryDict = queryString.parse(search);\n            return queryDict.authResponse ? queryDict.authResponse : '';\n        }\n        return '';\n    }\n    isSignInPending() {\n        try {\n            const isProtocolEcho = protocolEchoReplyDetection();\n            if (isProtocolEcho) {\n                Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n                return true;\n            }\n        }\n        catch (error) {\n            Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n        }\n        return !!this.getAuthResponseToken();\n    }\n    isUserSignedIn() {\n        return !!this.store.getSessionData().userData;\n    }\n    async handlePendingSignIn(authResponseToken = this.getAuthResponseToken()) {\n        const sessionData = this.store.getSessionData();\n        if (sessionData.userData) {\n            throw new LoginFailedError('Existing user session found.');\n        }\n        const transitKey = this.store.getSessionData().transitKey;\n        let coreNode = this.appConfig && this.appConfig.coreNode;\n        if (!coreNode) {\n            const network = new StacksMainnet();\n            coreNode = network.bnsLookupUrl;\n        }\n        const tokenPayload = decodeToken(authResponseToken).payload;\n        if (typeof tokenPayload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        const nameLookupURL = `${coreNode}${NAME_LOOKUP_PATH}`;\n        const fallbackLookupURLs = [\n            `https://stacks-node-api.stacks.co${NAME_LOOKUP_PATH}`,\n            `https://registrar.stacks.co${NAME_LOOKUP_PATH}`,\n        ].filter(url => url !== nameLookupURL);\n        const isValid = await verifyAuthResponse(authResponseToken, nameLookupURL, fallbackLookupURLs);\n        if (!isValid) {\n            throw new LoginFailedError('Invalid authentication response.');\n        }\n        let appPrivateKey = tokenPayload.private_key;\n        let coreSessionToken = tokenPayload.core_token;\n        if (isLaterVersion(tokenPayload.version, '1.1.0')) {\n            if (transitKey !== undefined && transitKey != null) {\n                if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n                    try {\n                        appPrivateKey = (await authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key));\n                    }\n                    catch (e) {\n                        Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n                        try {\n                            hexStringToECPair(tokenPayload.private_key);\n                        }\n                        catch (ecPairError) {\n                            throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' +\n                                ' that the transit key has changed during login.');\n                        }\n                    }\n                }\n                if (coreSessionToken !== undefined && coreSessionToken !== null) {\n                    try {\n                        coreSessionToken = (await authMessages.decryptPrivateKey(transitKey, coreSessionToken));\n                    }\n                    catch (e) {\n                        Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n                    }\n                }\n            }\n            else {\n                throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n            }\n        }\n        let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n        let gaiaAssociationToken;\n        if (isLaterVersion(tokenPayload.version, '1.2.0') &&\n            tokenPayload.hubUrl !== null &&\n            tokenPayload.hubUrl !== undefined) {\n            hubUrl = tokenPayload.hubUrl;\n        }\n        if (isLaterVersion(tokenPayload.version, '1.3.0') &&\n            tokenPayload.associationToken !== null &&\n            tokenPayload.associationToken !== undefined) {\n            gaiaAssociationToken = tokenPayload.associationToken;\n        }\n        const userData = {\n            username: tokenPayload.username,\n            profile: tokenPayload.profile,\n            email: tokenPayload.email,\n            decentralizedID: tokenPayload.iss,\n            identityAddress: getAddressFromDID(tokenPayload.iss),\n            appPrivateKey,\n            coreSessionToken,\n            authResponseToken,\n            hubUrl,\n            coreNode: tokenPayload.blockstackAPIUrl,\n            gaiaAssociationToken,\n        };\n        const profileURL = tokenPayload.profile_url;\n        if (!userData.profile && profileURL) {\n            const response = await fetchPrivate(profileURL);\n            if (!response.ok) {\n                userData.profile = Object.assign({}, DEFAULT_PROFILE);\n            }\n            else {\n                const responseText = await response.text();\n                const wrappedProfile = JSON.parse(responseText);\n                userData.profile = extractProfile(wrappedProfile[0].token);\n            }\n        }\n        else {\n            userData.profile = tokenPayload.profile;\n        }\n        sessionData.userData = userData;\n        this.store.setSessionData(sessionData);\n        return userData;\n    }\n    loadUserData() {\n        const userData = this.store.getSessionData().userData;\n        if (!userData) {\n            throw new InvalidStateError('No user data found. Did the user sign in?');\n        }\n        return userData;\n    }\n    encryptContent(content, options) {\n        const opts = Object.assign({}, options);\n        if (!opts.privateKey) {\n            opts.privateKey = this.loadUserData().appPrivateKey;\n        }\n        return encryptContent(content, opts);\n    }\n    decryptContent(content, options) {\n        const opts = Object.assign({}, options);\n        if (!opts.privateKey) {\n            opts.privateKey = this.loadUserData().appPrivateKey;\n        }\n        return decryptContent(content, opts);\n    }\n    signUserOut(redirectURL) {\n        this.store.deleteSessionData();\n        if (redirectURL) {\n            if (typeof location !== 'undefined' && location.href) {\n                location.href = redirectURL;\n            }\n        }\n    }\n}\n//# sourceMappingURL=userSession.js.map"]},"metadata":{},"sourceType":"module"}