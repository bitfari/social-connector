{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\n\nvar buffer_1 = require(\"buffer/\");\n\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nvar hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\n\nfunction c32encode(inputHex, minLength) {\n  // must be hex\n  if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n    throw new Error('Not a hex-encoded string');\n  }\n\n  if (inputHex.length % 2 !== 0) {\n    inputHex = \"0\" + inputHex;\n  }\n\n  inputHex = inputHex.toLowerCase();\n  var res = [];\n  var carry = 0;\n\n  for (var i = inputHex.length - 1; i >= 0; i--) {\n    if (carry < 4) {\n      var currentCode = hex.indexOf(inputHex[i]) >> carry;\n      var nextCode = 0;\n\n      if (i !== 0) {\n        nextCode = hex.indexOf(inputHex[i - 1]);\n      } // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n\n\n      var nextBits = 1 + carry;\n      var nextLowBits = nextCode % (1 << nextBits) << 5 - nextBits;\n      var curC32Digit = exports.c32[currentCode + nextLowBits];\n      carry = nextBits;\n      res.unshift(curC32Digit);\n    } else {\n      carry = 0;\n    }\n  }\n\n  var C32leadingZeros = 0;\n\n  for (var i = 0; i < res.length; i++) {\n    if (res[i] !== '0') {\n      break;\n    } else {\n      C32leadingZeros++;\n    }\n  }\n\n  res = res.slice(C32leadingZeros);\n  var zeroPrefix = buffer_1.Buffer.from(inputHex, 'hex').toString().match(/^\\u0000*/);\n  var numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n\n  for (var i = 0; i < numLeadingZeroBytesInHex; i++) {\n    res.unshift(exports.c32[0]);\n  }\n\n  if (minLength) {\n    var count = minLength - res.length;\n\n    for (var i = 0; i < count; i++) {\n      res.unshift(exports.c32[0]);\n    }\n  }\n\n  return res.join('');\n}\n\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\n\nfunction c32normalize(c32input) {\n  // must be upper-case\n  // replace all O's with 0's\n  // replace all I's and L's with 1's\n  return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\n\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\n\nfunction c32decode(c32input, minLength) {\n  c32input = c32normalize(c32input); // must result in a c32 string\n\n  if (!c32input.match(\"^[\" + exports.c32 + \"]*$\")) {\n    throw new Error('Not a c32-encoded string');\n  }\n\n  var zeroPrefix = c32input.match(\"^\" + exports.c32[0] + \"*\");\n  var numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n  var res = [];\n  var carry = 0;\n  var carryBits = 0;\n\n  for (var i = c32input.length - 1; i >= 0; i--) {\n    if (carryBits === 4) {\n      res.unshift(hex[carry]);\n      carryBits = 0;\n      carry = 0;\n    }\n\n    var currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n    var currentValue = currentCode + carry;\n    var currentHexDigit = hex[currentValue % 16];\n    carryBits += 1;\n    carry = currentValue >> 4;\n\n    if (carry > 1 << carryBits) {\n      throw new Error('Panic error in decoding.');\n    }\n\n    res.unshift(currentHexDigit);\n  } // one last carry\n\n\n  res.unshift(hex[carry]);\n\n  if (res.length % 2 === 1) {\n    res.unshift('0');\n  }\n\n  var hexLeadingZeros = 0;\n\n  for (var i = 0; i < res.length; i++) {\n    if (res[i] !== '0') {\n      break;\n    } else {\n      hexLeadingZeros++;\n    }\n  }\n\n  res = res.slice(hexLeadingZeros - hexLeadingZeros % 2);\n  var hexStr = res.join('');\n\n  for (var i = 0; i < numLeadingZeroBytes; i++) {\n    hexStr = \"00\" + hexStr;\n  }\n\n  if (minLength) {\n    var count = minLength * 2 - hexStr.length;\n\n    for (var i = 0; i < count; i += 2) {\n      hexStr = \"00\" + hexStr;\n    }\n  }\n\n  return hexStr;\n}\n\nexports.c32decode = c32decode;","map":{"version":3,"sources":["/Users/jvledesma/Downloads/bitfari-dev/www/node_modules/c32check/lib/encoding.js"],"names":["Object","defineProperty","exports","value","c32decode","c32normalize","c32encode","c32","buffer_1","require","hex","inputHex","minLength","match","Error","length","toLowerCase","res","carry","i","currentCode","indexOf","nextCode","nextBits","nextLowBits","curC32Digit","unshift","C32leadingZeros","slice","zeroPrefix","Buffer","from","toString","numLeadingZeroBytesInHex","count","join","c32input","toUpperCase","replace","numLeadingZeroBytes","carryBits","currentValue","currentHexDigit","hexLeadingZeros","hexStr"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoBF,OAAO,CAACG,YAAR,GAAuBH,OAAO,CAACI,SAAR,GAAoBJ,OAAO,CAACK,GAAR,GAAc,KAAK,CAAlF;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACAP,OAAO,CAACK,GAAR,GAAc,kCAAd;AACA,IAAIG,GAAG,GAAG,kBAAV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASJ,SAAT,CAAmBK,QAAnB,EAA6BC,SAA7B,EAAwC;AACpC;AACA,MAAI,CAACD,QAAQ,CAACE,KAAT,CAAe,gBAAf,CAAL,EAAuC;AACnC,UAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACH;;AACD,MAAKH,QAAQ,CAACI,MAAV,GAAoB,CAApB,KAA0B,CAA9B,EAAiC;AAC7BJ,IAAAA,QAAQ,GAAG,MAAMA,QAAjB;AACH;;AACDA,EAAAA,QAAQ,GAAGA,QAAQ,CAACK,WAAT,EAAX;AACA,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,CAAC,GAAGR,QAAQ,CAACI,MAAT,GAAkB,CAA/B,EAAkCI,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC3C,QAAID,KAAK,GAAG,CAAZ,EAAe;AACX,UAAIE,WAAW,GAAGV,GAAG,CAACW,OAAJ,CAAYV,QAAQ,CAACQ,CAAD,CAApB,KAA4BD,KAA9C;AACA,UAAII,QAAQ,GAAG,CAAf;;AACA,UAAIH,CAAC,KAAK,CAAV,EAAa;AACTG,QAAAA,QAAQ,GAAGZ,GAAG,CAACW,OAAJ,CAAYV,QAAQ,CAACQ,CAAC,GAAG,CAAL,CAApB,CAAX;AACH,OALU,CAMX;;;AACA,UAAII,QAAQ,GAAG,IAAIL,KAAnB;AACA,UAAIM,WAAW,GAAIF,QAAQ,IAAI,KAAKC,QAAT,CAAT,IAAiC,IAAIA,QAAvD;AACA,UAAIE,WAAW,GAAGvB,OAAO,CAACK,GAAR,CAAYa,WAAW,GAAGI,WAA1B,CAAlB;AACAN,MAAAA,KAAK,GAAGK,QAAR;AACAN,MAAAA,GAAG,CAACS,OAAJ,CAAYD,WAAZ;AACH,KAZD,MAaK;AACDP,MAAAA,KAAK,GAAG,CAAR;AACH;AACJ;;AACD,MAAIS,eAAe,GAAG,CAAtB;;AACA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACF,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;AACjC,QAAIF,GAAG,CAACE,CAAD,CAAH,KAAW,GAAf,EAAoB;AAChB;AACH,KAFD,MAGK;AACDQ,MAAAA,eAAe;AAClB;AACJ;;AACDV,EAAAA,GAAG,GAAGA,GAAG,CAACW,KAAJ,CAAUD,eAAV,CAAN;AACA,MAAIE,UAAU,GAAGrB,QAAQ,CAACsB,MAAT,CAAgBC,IAAhB,CAAqBpB,QAArB,EAA+B,KAA/B,EAAsCqB,QAAtC,GAAiDnB,KAAjD,CAAuD,UAAvD,CAAjB;AACA,MAAIoB,wBAAwB,GAAGJ,UAAU,GAAGA,UAAU,CAAC,CAAD,CAAV,CAAcd,MAAjB,GAA0B,CAAnE;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,wBAApB,EAA8Cd,CAAC,EAA/C,EAAmD;AAC/CF,IAAAA,GAAG,CAACS,OAAJ,CAAYxB,OAAO,CAACK,GAAR,CAAY,CAAZ,CAAZ;AACH;;AACD,MAAIK,SAAJ,EAAe;AACX,QAAIsB,KAAK,GAAGtB,SAAS,GAAGK,GAAG,CAACF,MAA5B;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,KAApB,EAA2Bf,CAAC,EAA5B,EAAgC;AAC5BF,MAAAA,GAAG,CAACS,OAAJ,CAAYxB,OAAO,CAACK,GAAR,CAAY,CAAZ,CAAZ;AACH;AACJ;;AACD,SAAOU,GAAG,CAACkB,IAAJ,CAAS,EAAT,CAAP;AACH;;AACDjC,OAAO,CAACI,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,YAAT,CAAsB+B,QAAtB,EAAgC;AAC5B;AACA;AACA;AACA,SAAOA,QAAQ,CAACC,WAAT,GACFC,OADE,CACM,IADN,EACY,GADZ,EAEFA,OAFE,CAEM,MAFN,EAEc,GAFd,CAAP;AAGH;;AACDpC,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,SAAT,CAAmBgC,QAAnB,EAA6BxB,SAA7B,EAAwC;AACpCwB,EAAAA,QAAQ,GAAG/B,YAAY,CAAC+B,QAAD,CAAvB,CADoC,CAEpC;;AACA,MAAI,CAACA,QAAQ,CAACvB,KAAT,CAAe,OAAOX,OAAO,CAACK,GAAf,GAAqB,KAApC,CAAL,EAAiD;AAC7C,UAAM,IAAIO,KAAJ,CAAU,0BAAV,CAAN;AACH;;AACD,MAAIe,UAAU,GAAGO,QAAQ,CAACvB,KAAT,CAAe,MAAMX,OAAO,CAACK,GAAR,CAAY,CAAZ,CAAN,GAAuB,GAAtC,CAAjB;AACA,MAAIgC,mBAAmB,GAAGV,UAAU,GAAGA,UAAU,CAAC,CAAD,CAAV,CAAcd,MAAjB,GAA0B,CAA9D;AACA,MAAIE,GAAG,GAAG,EAAV;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIsB,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAIrB,CAAC,GAAGiB,QAAQ,CAACrB,MAAT,GAAkB,CAA/B,EAAkCI,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC3C,QAAIqB,SAAS,KAAK,CAAlB,EAAqB;AACjBvB,MAAAA,GAAG,CAACS,OAAJ,CAAYhB,GAAG,CAACQ,KAAD,CAAf;AACAsB,MAAAA,SAAS,GAAG,CAAZ;AACAtB,MAAAA,KAAK,GAAG,CAAR;AACH;;AACD,QAAIE,WAAW,GAAGlB,OAAO,CAACK,GAAR,CAAYc,OAAZ,CAAoBe,QAAQ,CAACjB,CAAD,CAA5B,KAAoCqB,SAAtD;AACA,QAAIC,YAAY,GAAGrB,WAAW,GAAGF,KAAjC;AACA,QAAIwB,eAAe,GAAGhC,GAAG,CAAC+B,YAAY,GAAG,EAAhB,CAAzB;AACAD,IAAAA,SAAS,IAAI,CAAb;AACAtB,IAAAA,KAAK,GAAGuB,YAAY,IAAI,CAAxB;;AACA,QAAIvB,KAAK,GAAG,KAAKsB,SAAjB,EAA4B;AACxB,YAAM,IAAI1B,KAAJ,CAAU,0BAAV,CAAN;AACH;;AACDG,IAAAA,GAAG,CAACS,OAAJ,CAAYgB,eAAZ;AACH,GA1BmC,CA2BpC;;;AACAzB,EAAAA,GAAG,CAACS,OAAJ,CAAYhB,GAAG,CAACQ,KAAD,CAAf;;AACA,MAAID,GAAG,CAACF,MAAJ,GAAa,CAAb,KAAmB,CAAvB,EAA0B;AACtBE,IAAAA,GAAG,CAACS,OAAJ,CAAY,GAAZ;AACH;;AACD,MAAIiB,eAAe,GAAG,CAAtB;;AACA,OAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACF,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;AACjC,QAAIF,GAAG,CAACE,CAAD,CAAH,KAAW,GAAf,EAAoB;AAChB;AACH,KAFD,MAGK;AACDwB,MAAAA,eAAe;AAClB;AACJ;;AACD1B,EAAAA,GAAG,GAAGA,GAAG,CAACW,KAAJ,CAAUe,eAAe,GAAIA,eAAe,GAAG,CAA/C,CAAN;AACA,MAAIC,MAAM,GAAG3B,GAAG,CAACkB,IAAJ,CAAS,EAAT,CAAb;;AACA,OAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,mBAApB,EAAyCpB,CAAC,EAA1C,EAA8C;AAC1CyB,IAAAA,MAAM,GAAG,OAAOA,MAAhB;AACH;;AACD,MAAIhC,SAAJ,EAAe;AACX,QAAIsB,KAAK,GAAGtB,SAAS,GAAG,CAAZ,GAAgBgC,MAAM,CAAC7B,MAAnC;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,KAApB,EAA2Bf,CAAC,IAAI,CAAhC,EAAmC;AAC/ByB,MAAAA,MAAM,GAAG,OAAOA,MAAhB;AACH;AACJ;;AACD,SAAOA,MAAP;AACH;;AACD1C,OAAO,CAACE,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nvar buffer_1 = require(\"buffer/\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nvar hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if ((inputHex.length) % 2 !== 0) {\n        inputHex = \"0\" + inputHex;\n    }\n    inputHex = inputHex.toLowerCase();\n    var res = [];\n    var carry = 0;\n    for (var i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            var currentCode = hex.indexOf(inputHex[i]) >> carry;\n            var nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            var nextBits = 1 + carry;\n            var nextLowBits = (nextCode % (1 << nextBits)) << (5 - nextBits);\n            var curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    var C32leadingZeros = 0;\n    for (var i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    var zeroPrefix = buffer_1.Buffer.from(inputHex, 'hex').toString().match(/^\\u0000*/);\n    var numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (var i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        var count = minLength - res.length;\n        for (var i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase()\n        .replace(/O/g, '0')\n        .replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(\"^[\" + exports.c32 + \"]*$\")) {\n        throw new Error('Not a c32-encoded string');\n    }\n    var zeroPrefix = c32input.match(\"^\" + exports.c32[0] + \"*\");\n    var numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    var res = [];\n    var carry = 0;\n    var carryBits = 0;\n    for (var i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        var currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        var currentValue = currentCode + carry;\n        var currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    var hexLeadingZeros = 0;\n    for (var i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    var hexStr = res.join('');\n    for (var i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = \"00\" + hexStr;\n    }\n    if (minLength) {\n        var count = minLength * 2 - hexStr.length;\n        for (var i = 0; i < count; i += 2) {\n            hexStr = \"00\" + hexStr;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n"]},"metadata":{},"sourceType":"script"}