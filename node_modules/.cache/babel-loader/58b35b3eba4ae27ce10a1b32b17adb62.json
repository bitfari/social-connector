{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32checkDecode = exports.c32checkEncode = void 0;\n\nvar buffer_1 = require(\"buffer/\");\n\nvar encoding_1 = require(\"./encoding\");\n\nvar cross_sha256_1 = require(\"cross-sha256\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\n\n\nfunction c32checksum(dataHex) {\n  var dataHash = cross_sha256_1.hashSha256(cross_sha256_1.hashSha256(buffer_1.Buffer.from(dataHex, 'hex')));\n  var checksum = dataHash.slice(0, 4).toString('hex');\n  return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\n\n\nfunction c32checkEncode(version, data) {\n  if (version < 0 || version >= 32) {\n    throw new Error('Invalid version (must be between 0 and 31)');\n  }\n\n  if (!data.match(/^[0-9a-fA-F]*$/)) {\n    throw new Error('Invalid data (not a hex string)');\n  }\n\n  data = data.toLowerCase();\n\n  if (data.length % 2 !== 0) {\n    data = \"0\" + data;\n  }\n\n  var versionHex = version.toString(16);\n\n  if (versionHex.length === 1) {\n    versionHex = \"0\" + versionHex;\n  }\n\n  var checksumHex = c32checksum(\"\" + versionHex + data);\n  var c32str = encoding_1.c32encode(\"\" + data + checksumHex);\n  return \"\" + encoding_1.c32[version] + c32str;\n}\n\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\n\nfunction c32checkDecode(c32data) {\n  c32data = encoding_1.c32normalize(c32data);\n  var dataHex = encoding_1.c32decode(c32data.slice(1));\n  var versionChar = c32data[0];\n  var version = encoding_1.c32.indexOf(versionChar);\n  var checksum = dataHex.slice(-8);\n  var versionHex = version.toString(16);\n\n  if (versionHex.length === 1) {\n    versionHex = \"0\" + versionHex;\n  }\n\n  if (c32checksum(\"\" + versionHex + dataHex.substring(0, dataHex.length - 8)) !== checksum) {\n    throw new Error('Invalid c32check string: checksum mismatch');\n  }\n\n  return [version, dataHex.substring(0, dataHex.length - 8)];\n}\n\nexports.c32checkDecode = c32checkDecode;","map":{"version":3,"sources":["/Users/jvledesma/www-bitfari/node_modules/c32check/lib/checksum.js"],"names":["Object","defineProperty","exports","value","c32checkDecode","c32checkEncode","buffer_1","require","encoding_1","cross_sha256_1","c32checksum","dataHex","dataHash","hashSha256","Buffer","from","checksum","slice","toString","version","data","Error","match","toLowerCase","length","versionHex","checksumHex","c32str","c32encode","c32","c32data","c32normalize","c32decode","versionChar","indexOf","substring"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar encoding_1 = require(\"./encoding\");\nvar cross_sha256_1 = require(\"cross-sha256\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    var dataHash = cross_sha256_1.hashSha256(cross_sha256_1.hashSha256(buffer_1.Buffer.from(dataHex, 'hex')));\n    var checksum = dataHash.slice(0, 4).toString('hex');\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = \"0\" + data;\n    }\n    var versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = \"0\" + versionHex;\n    }\n    var checksumHex = c32checksum(\"\" + versionHex + data);\n    var c32str = encoding_1.c32encode(\"\" + data + checksumHex);\n    return \"\" + encoding_1.c32[version] + c32str;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = encoding_1.c32normalize(c32data);\n    var dataHex = encoding_1.c32decode(c32data.slice(1));\n    var versionChar = c32data[0];\n    var version = encoding_1.c32.indexOf(versionChar);\n    var checksum = dataHex.slice(-8);\n    var versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = \"0\" + versionHex;\n    }\n    if (c32checksum(\"\" + versionHex + dataHex.substring(0, dataHex.length - 8)) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n"]},"metadata":{},"sourceType":"script"}