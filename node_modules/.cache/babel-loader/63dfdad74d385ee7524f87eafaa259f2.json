{"ast":null,"code":"import { tokenRegex, revFormat, formats } from \"./formatting\";\nimport { defaults } from \"../types/options\";\nimport { english } from \"../l10n/default\";\nexport var createDateFormatter = function (_a) {\n  var _b = _a.config,\n      config = _b === void 0 ? defaults : _b,\n      _c = _a.l10n,\n      l10n = _c === void 0 ? english : _c,\n      _d = _a.isMobile,\n      isMobile = _d === void 0 ? false : _d;\n  return function (dateObj, frmt, overrideLocale) {\n    var locale = overrideLocale || l10n;\n\n    if (config.formatDate !== undefined && !isMobile) {\n      return config.formatDate(dateObj, frmt, locale);\n    }\n\n    return frmt.split(\"\").map(function (c, i, arr) {\n      return formats[c] && arr[i - 1] !== \"\\\\\" ? formats[c](dateObj, locale, config) : c !== \"\\\\\" ? c : \"\";\n    }).join(\"\");\n  };\n};\nexport var createDateParser = function (_a) {\n  var _b = _a.config,\n      config = _b === void 0 ? defaults : _b,\n      _c = _a.l10n,\n      l10n = _c === void 0 ? english : _c;\n  return function (date, givenFormat, timeless, customLocale) {\n    if (date !== 0 && !date) return undefined;\n    var locale = customLocale || l10n;\n    var parsedDate;\n    var dateOrig = date;\n    if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== \"string\" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === \"string\") {\n      var format = givenFormat || (config || defaults).dateFormat;\n      var datestr = String(date).trim();\n\n      if (datestr === \"today\") {\n        parsedDate = new Date();\n        timeless = true;\n      } else if (config && config.parseDate) {\n        parsedDate = config.parseDate(date, format);\n      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {\n        parsedDate = new Date(date);\n      } else {\n        var matched = void 0,\n            ops = [];\n\n        for (var i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n          var token = format[i];\n          var isBackSlash = token === \"\\\\\";\n          var escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n\n          if (tokenRegex[token] && !escaped) {\n            regexStr += tokenRegex[token];\n            var match = new RegExp(regexStr).exec(date);\n\n            if (match && (matched = true)) {\n              ops[token !== \"Y\" ? \"push\" : \"unshift\"]({\n                fn: revFormat[token],\n                val: match[++matchIndex]\n              });\n            }\n          } else if (!isBackSlash) regexStr += \".\";\n        }\n\n        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));\n        ops.forEach(function (_a) {\n          var fn = _a.fn,\n              val = _a.val;\n          return parsedDate = fn(parsedDate, val, locale) || parsedDate;\n        });\n        parsedDate = matched ? parsedDate : undefined;\n      }\n    }\n\n    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {\n      config.errorHandler(new Error(\"Invalid date provided: \" + dateOrig));\n      return undefined;\n    }\n\n    if (timeless === true) parsedDate.setHours(0, 0, 0, 0);\n    return parsedDate;\n  };\n};\nexport function compareDates(date1, date2, timeless) {\n  if (timeless === void 0) {\n    timeless = true;\n  }\n\n  if (timeless !== false) {\n    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);\n  }\n\n  return date1.getTime() - date2.getTime();\n}\nexport function compareTimes(date1, date2) {\n  return 3600 * (date1.getHours() - date2.getHours()) + 60 * (date1.getMinutes() - date2.getMinutes()) + date1.getSeconds() - date2.getSeconds();\n}\nexport var isBetween = function (ts, ts1, ts2) {\n  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);\n};\nexport var calculateSecondsSinceMidnight = function (hours, minutes, seconds) {\n  return hours * 3600 + minutes * 60 + seconds;\n};\nexport var parseSeconds = function (secondsSinceMidnight) {\n  var hours = Math.floor(secondsSinceMidnight / 3600),\n      minutes = (secondsSinceMidnight - hours * 3600) / 60;\n  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];\n};\nexport var duration = {\n  DAY: 86400000\n};\nexport function getDefaultHours(config) {\n  var hours = config.defaultHour;\n  var minutes = config.defaultMinute;\n  var seconds = config.defaultSeconds;\n\n  if (config.minDate !== undefined) {\n    var minHour = config.minDate.getHours();\n    var minMinutes = config.minDate.getMinutes();\n    var minSeconds = config.minDate.getSeconds();\n\n    if (hours < minHour) {\n      hours = minHour;\n    }\n\n    if (hours === minHour && minutes < minMinutes) {\n      minutes = minMinutes;\n    }\n\n    if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();\n  }\n\n  if (config.maxDate !== undefined) {\n    var maxHr = config.maxDate.getHours();\n    var maxMinutes = config.maxDate.getMinutes();\n    hours = Math.min(hours, maxHr);\n    if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);\n    if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();\n  }\n\n  return {\n    hours: hours,\n    minutes: minutes,\n    seconds: seconds\n  };\n}","map":{"version":3,"sources":["/Users/jvledesma/Downloads/react-version/full-version/node_modules/react-flatpickr/node_modules/flatpickr/dist/esm/utils/dates.js"],"names":["tokenRegex","revFormat","formats","defaults","english","createDateFormatter","_a","_b","config","_c","l10n","_d","isMobile","dateObj","frmt","overrideLocale","locale","formatDate","undefined","split","map","c","i","arr","join","createDateParser","date","givenFormat","timeless","customLocale","parsedDate","dateOrig","Date","getTime","toFixed","format","dateFormat","datestr","String","trim","parseDate","test","matched","ops","matchIndex","regexStr","length","token","isBackSlash","escaped","match","RegExp","exec","fn","val","noCalendar","getFullYear","setHours","forEach","isNaN","errorHandler","Error","compareDates","date1","date2","compareTimes","getHours","getMinutes","getSeconds","isBetween","ts","ts1","ts2","Math","min","max","calculateSecondsSinceMidnight","hours","minutes","seconds","parseSeconds","secondsSinceMidnight","floor","duration","DAY","getDefaultHours","defaultHour","defaultMinute","defaultSeconds","minDate","minHour","minMinutes","minSeconds","maxDate","maxHr","maxMinutes"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,SAArB,EAAgCC,OAAhC,QAAgD,cAAhD;AACA,SAASC,QAAT,QAAyB,kBAAzB;AACA,SAASC,OAAT,QAAwB,iBAAxB;AACA,OAAO,IAAIC,mBAAmB,GAAG,UAAUC,EAAV,EAAc;AAC3C,MAAIC,EAAE,GAAGD,EAAE,CAACE,MAAZ;AAAA,MAAoBA,MAAM,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBJ,QAAhB,GAA2BI,EAAxD;AAAA,MAA4DE,EAAE,GAAGH,EAAE,CAACI,IAApE;AAAA,MAA0EA,IAAI,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBL,OAAhB,GAA0BK,EAA3G;AAAA,MAA+GE,EAAE,GAAGL,EAAE,CAACM,QAAvH;AAAA,MAAiIA,QAAQ,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAApK;AACA,SAAO,UAAUE,OAAV,EAAmBC,IAAnB,EAAyBC,cAAzB,EAAyC;AAC5C,QAAIC,MAAM,GAAGD,cAAc,IAAIL,IAA/B;;AACA,QAAIF,MAAM,CAACS,UAAP,KAAsBC,SAAtB,IAAmC,CAACN,QAAxC,EAAkD;AAC9C,aAAOJ,MAAM,CAACS,UAAP,CAAkBJ,OAAlB,EAA2BC,IAA3B,EAAiCE,MAAjC,CAAP;AACH;;AACD,WAAOF,IAAI,CACNK,KADE,CACI,EADJ,EAEFC,GAFE,CAEE,UAAUC,CAAV,EAAaC,CAAb,EAAgBC,GAAhB,EAAqB;AAC1B,aAAOrB,OAAO,CAACmB,CAAD,CAAP,IAAcE,GAAG,CAACD,CAAC,GAAG,CAAL,CAAH,KAAe,IAA7B,GACDpB,OAAO,CAACmB,CAAD,CAAP,CAAWR,OAAX,EAAoBG,MAApB,EAA4BR,MAA5B,CADC,GAEDa,CAAC,KAAK,IAAN,GACIA,CADJ,GAEI,EAJV;AAKH,KARM,EASFG,IATE,CASG,EATH,CAAP;AAUH,GAfD;AAgBH,CAlBM;AAmBP,OAAO,IAAIC,gBAAgB,GAAG,UAAUnB,EAAV,EAAc;AACxC,MAAIC,EAAE,GAAGD,EAAE,CAACE,MAAZ;AAAA,MAAoBA,MAAM,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBJ,QAAhB,GAA2BI,EAAxD;AAAA,MAA4DE,EAAE,GAAGH,EAAE,CAACI,IAApE;AAAA,MAA0EA,IAAI,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBL,OAAhB,GAA0BK,EAA3G;AACA,SAAO,UAAUiB,IAAV,EAAgBC,WAAhB,EAA6BC,QAA7B,EAAuCC,YAAvC,EAAqD;AACxD,QAAIH,IAAI,KAAK,CAAT,IAAc,CAACA,IAAnB,EACI,OAAOR,SAAP;AACJ,QAAIF,MAAM,GAAGa,YAAY,IAAInB,IAA7B;AACA,QAAIoB,UAAJ;AACA,QAAIC,QAAQ,GAAGL,IAAf;AACA,QAAIA,IAAI,YAAYM,IAApB,EACIF,UAAU,GAAG,IAAIE,IAAJ,CAASN,IAAI,CAACO,OAAL,EAAT,CAAb,CADJ,KAEK,IAAI,OAAOP,IAAP,KAAgB,QAAhB,IACLA,IAAI,CAACQ,OAAL,KAAiBhB,SADhB,EAEDY,UAAU,GAAG,IAAIE,IAAJ,CAASN,IAAT,CAAb,CAFC,KAGA,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC/B,UAAIS,MAAM,GAAGR,WAAW,IAAI,CAACnB,MAAM,IAAIL,QAAX,EAAqBiC,UAAjD;AACA,UAAIC,OAAO,GAAGC,MAAM,CAACZ,IAAD,CAAN,CAAaa,IAAb,EAAd;;AACA,UAAIF,OAAO,KAAK,OAAhB,EAAyB;AACrBP,QAAAA,UAAU,GAAG,IAAIE,IAAJ,EAAb;AACAJ,QAAAA,QAAQ,GAAG,IAAX;AACH,OAHD,MAIK,IAAIpB,MAAM,IAAIA,MAAM,CAACgC,SAArB,EAAgC;AACjCV,QAAAA,UAAU,GAAGtB,MAAM,CAACgC,SAAP,CAAiBd,IAAjB,EAAuBS,MAAvB,CAAb;AACH,OAFI,MAGA,IAAI,KAAKM,IAAL,CAAUJ,OAAV,KACL,OAAOI,IAAP,CAAYJ,OAAZ,CADC,EACqB;AACtBP,QAAAA,UAAU,GAAG,IAAIE,IAAJ,CAASN,IAAT,CAAb;AACH,OAHI,MAIA;AACD,YAAIgB,OAAO,GAAG,KAAK,CAAnB;AAAA,YAAsBC,GAAG,GAAG,EAA5B;;AACA,aAAK,IAAIrB,CAAC,GAAG,CAAR,EAAWsB,UAAU,GAAG,CAAxB,EAA2BC,QAAQ,GAAG,EAA3C,EAA+CvB,CAAC,GAAGa,MAAM,CAACW,MAA1D,EAAkExB,CAAC,EAAnE,EAAuE;AACnE,cAAIyB,KAAK,GAAGZ,MAAM,CAACb,CAAD,CAAlB;AACA,cAAI0B,WAAW,GAAGD,KAAK,KAAK,IAA5B;AACA,cAAIE,OAAO,GAAGd,MAAM,CAACb,CAAC,GAAG,CAAL,CAAN,KAAkB,IAAlB,IAA0B0B,WAAxC;;AACA,cAAIhD,UAAU,CAAC+C,KAAD,CAAV,IAAqB,CAACE,OAA1B,EAAmC;AAC/BJ,YAAAA,QAAQ,IAAI7C,UAAU,CAAC+C,KAAD,CAAtB;AACA,gBAAIG,KAAK,GAAG,IAAIC,MAAJ,CAAWN,QAAX,EAAqBO,IAArB,CAA0B1B,IAA1B,CAAZ;;AACA,gBAAIwB,KAAK,KAAKR,OAAO,GAAG,IAAf,CAAT,EAA+B;AAC3BC,cAAAA,GAAG,CAACI,KAAK,KAAK,GAAV,GAAgB,MAAhB,GAAyB,SAA1B,CAAH,CAAwC;AACpCM,gBAAAA,EAAE,EAAEpD,SAAS,CAAC8C,KAAD,CADuB;AAEpCO,gBAAAA,GAAG,EAAEJ,KAAK,CAAC,EAAEN,UAAH;AAF0B,eAAxC;AAIH;AACJ,WATD,MAUK,IAAI,CAACI,WAAL,EACDH,QAAQ,IAAI,GAAZ;AACP;;AACDf,QAAAA,UAAU,GACN,CAACtB,MAAD,IAAW,CAACA,MAAM,CAAC+C,UAAnB,GACM,IAAIvB,IAAJ,CAAS,IAAIA,IAAJ,GAAWwB,WAAX,EAAT,EAAmC,CAAnC,EAAsC,CAAtC,EAAyC,CAAzC,EAA4C,CAA5C,EAA+C,CAA/C,EAAkD,CAAlD,CADN,GAEM,IAAIxB,IAAJ,CAAS,IAAIA,IAAJ,GAAWyB,QAAX,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,CAAT,CAHV;AAIAd,QAAAA,GAAG,CAACe,OAAJ,CAAY,UAAUpD,EAAV,EAAc;AACtB,cAAI+C,EAAE,GAAG/C,EAAE,CAAC+C,EAAZ;AAAA,cAAgBC,GAAG,GAAGhD,EAAE,CAACgD,GAAzB;AACA,iBAAQxB,UAAU,GAAGuB,EAAE,CAACvB,UAAD,EAAawB,GAAb,EAAkBtC,MAAlB,CAAF,IAA+Bc,UAApD;AACH,SAHD;AAIAA,QAAAA,UAAU,GAAGY,OAAO,GAAGZ,UAAH,GAAgBZ,SAApC;AACH;AACJ;;AACD,QAAI,EAAEY,UAAU,YAAYE,IAAtB,IAA8B,CAAC2B,KAAK,CAAC7B,UAAU,CAACG,OAAX,EAAD,CAAtC,CAAJ,EAAmE;AAC/DzB,MAAAA,MAAM,CAACoD,YAAP,CAAoB,IAAIC,KAAJ,CAAU,4BAA4B9B,QAAtC,CAApB;AACA,aAAOb,SAAP;AACH;;AACD,QAAIU,QAAQ,KAAK,IAAjB,EACIE,UAAU,CAAC2B,QAAX,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B;AACJ,WAAO3B,UAAP;AACH,GA9DD;AA+DH,CAjEM;AAkEP,OAAO,SAASgC,YAAT,CAAsBC,KAAtB,EAA6BC,KAA7B,EAAoCpC,QAApC,EAA8C;AACjD,MAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,IAAAA,QAAQ,GAAG,IAAX;AAAkB;;AAC7C,MAAIA,QAAQ,KAAK,KAAjB,EAAwB;AACpB,WAAQ,IAAII,IAAJ,CAAS+B,KAAK,CAAC9B,OAAN,EAAT,EAA0BwB,QAA1B,CAAmC,CAAnC,EAAsC,CAAtC,EAAyC,CAAzC,EAA4C,CAA5C,IACJ,IAAIzB,IAAJ,CAASgC,KAAK,CAAC/B,OAAN,EAAT,EAA0BwB,QAA1B,CAAmC,CAAnC,EAAsC,CAAtC,EAAyC,CAAzC,EAA4C,CAA5C,CADJ;AAEH;;AACD,SAAOM,KAAK,CAAC9B,OAAN,KAAkB+B,KAAK,CAAC/B,OAAN,EAAzB;AACH;AACD,OAAO,SAASgC,YAAT,CAAsBF,KAAtB,EAA6BC,KAA7B,EAAoC;AACvC,SAAQ,QAAQD,KAAK,CAACG,QAAN,KAAmBF,KAAK,CAACE,QAAN,EAA3B,IACJ,MAAMH,KAAK,CAACI,UAAN,KAAqBH,KAAK,CAACG,UAAN,EAA3B,CADI,GAEJJ,KAAK,CAACK,UAAN,EAFI,GAGJJ,KAAK,CAACI,UAAN,EAHJ;AAIH;AACD,OAAO,IAAIC,SAAS,GAAG,UAAUC,EAAV,EAAcC,GAAd,EAAmBC,GAAnB,EAAwB;AAC3C,SAAOF,EAAE,GAAGG,IAAI,CAACC,GAAL,CAASH,GAAT,EAAcC,GAAd,CAAL,IAA2BF,EAAE,GAAGG,IAAI,CAACE,GAAL,CAASJ,GAAT,EAAcC,GAAd,CAAvC;AACH,CAFM;AAGP,OAAO,IAAII,6BAA6B,GAAG,UAAUC,KAAV,EAAiBC,OAAjB,EAA0BC,OAA1B,EAAmC;AAC1E,SAAOF,KAAK,GAAG,IAAR,GAAeC,OAAO,GAAG,EAAzB,GAA8BC,OAArC;AACH,CAFM;AAGP,OAAO,IAAIC,YAAY,GAAG,UAAUC,oBAAV,EAAgC;AACtD,MAAIJ,KAAK,GAAGJ,IAAI,CAACS,KAAL,CAAWD,oBAAoB,GAAG,IAAlC,CAAZ;AAAA,MAAqDH,OAAO,GAAG,CAACG,oBAAoB,GAAGJ,KAAK,GAAG,IAAhC,IAAwC,EAAvG;AACA,SAAO,CAACA,KAAD,EAAQC,OAAR,EAAiBG,oBAAoB,GAAGJ,KAAK,GAAG,IAA/B,GAAsCC,OAAO,GAAG,EAAjE,CAAP;AACH,CAHM;AAIP,OAAO,IAAIK,QAAQ,GAAG;AAClBC,EAAAA,GAAG,EAAE;AADa,CAAf;AAGP,OAAO,SAASC,eAAT,CAAyB7E,MAAzB,EAAiC;AACpC,MAAIqE,KAAK,GAAGrE,MAAM,CAAC8E,WAAnB;AACA,MAAIR,OAAO,GAAGtE,MAAM,CAAC+E,aAArB;AACA,MAAIR,OAAO,GAAGvE,MAAM,CAACgF,cAArB;;AACA,MAAIhF,MAAM,CAACiF,OAAP,KAAmBvE,SAAvB,EAAkC;AAC9B,QAAIwE,OAAO,GAAGlF,MAAM,CAACiF,OAAP,CAAevB,QAAf,EAAd;AACA,QAAIyB,UAAU,GAAGnF,MAAM,CAACiF,OAAP,CAAetB,UAAf,EAAjB;AACA,QAAIyB,UAAU,GAAGpF,MAAM,CAACiF,OAAP,CAAerB,UAAf,EAAjB;;AACA,QAAIS,KAAK,GAAGa,OAAZ,EAAqB;AACjBb,MAAAA,KAAK,GAAGa,OAAR;AACH;;AACD,QAAIb,KAAK,KAAKa,OAAV,IAAqBZ,OAAO,GAAGa,UAAnC,EAA+C;AAC3Cb,MAAAA,OAAO,GAAGa,UAAV;AACH;;AACD,QAAId,KAAK,KAAKa,OAAV,IAAqBZ,OAAO,KAAKa,UAAjC,IAA+CZ,OAAO,GAAGa,UAA7D,EACIb,OAAO,GAAGvE,MAAM,CAACiF,OAAP,CAAerB,UAAf,EAAV;AACP;;AACD,MAAI5D,MAAM,CAACqF,OAAP,KAAmB3E,SAAvB,EAAkC;AAC9B,QAAI4E,KAAK,GAAGtF,MAAM,CAACqF,OAAP,CAAe3B,QAAf,EAAZ;AACA,QAAI6B,UAAU,GAAGvF,MAAM,CAACqF,OAAP,CAAe1B,UAAf,EAAjB;AACAU,IAAAA,KAAK,GAAGJ,IAAI,CAACC,GAAL,CAASG,KAAT,EAAgBiB,KAAhB,CAAR;AACA,QAAIjB,KAAK,KAAKiB,KAAd,EACIhB,OAAO,GAAGL,IAAI,CAACC,GAAL,CAASqB,UAAT,EAAqBjB,OAArB,CAAV;AACJ,QAAID,KAAK,KAAKiB,KAAV,IAAmBhB,OAAO,KAAKiB,UAAnC,EACIhB,OAAO,GAAGvE,MAAM,CAACqF,OAAP,CAAezB,UAAf,EAAV;AACP;;AACD,SAAO;AAAES,IAAAA,KAAK,EAAEA,KAAT;AAAgBC,IAAAA,OAAO,EAAEA,OAAzB;AAAkCC,IAAAA,OAAO,EAAEA;AAA3C,GAAP;AACH","sourcesContent":["import { tokenRegex, revFormat, formats, } from \"./formatting\";\nimport { defaults } from \"../types/options\";\nimport { english } from \"../l10n/default\";\nexport var createDateFormatter = function (_a) {\n    var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;\n    return function (dateObj, frmt, overrideLocale) {\n        var locale = overrideLocale || l10n;\n        if (config.formatDate !== undefined && !isMobile) {\n            return config.formatDate(dateObj, frmt, locale);\n        }\n        return frmt\n            .split(\"\")\n            .map(function (c, i, arr) {\n            return formats[c] && arr[i - 1] !== \"\\\\\"\n                ? formats[c](dateObj, locale, config)\n                : c !== \"\\\\\"\n                    ? c\n                    : \"\";\n        })\n            .join(\"\");\n    };\n};\nexport var createDateParser = function (_a) {\n    var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;\n    return function (date, givenFormat, timeless, customLocale) {\n        if (date !== 0 && !date)\n            return undefined;\n        var locale = customLocale || l10n;\n        var parsedDate;\n        var dateOrig = date;\n        if (date instanceof Date)\n            parsedDate = new Date(date.getTime());\n        else if (typeof date !== \"string\" &&\n            date.toFixed !== undefined)\n            parsedDate = new Date(date);\n        else if (typeof date === \"string\") {\n            var format = givenFormat || (config || defaults).dateFormat;\n            var datestr = String(date).trim();\n            if (datestr === \"today\") {\n                parsedDate = new Date();\n                timeless = true;\n            }\n            else if (config && config.parseDate) {\n                parsedDate = config.parseDate(date, format);\n            }\n            else if (/Z$/.test(datestr) ||\n                /GMT$/.test(datestr)) {\n                parsedDate = new Date(date);\n            }\n            else {\n                var matched = void 0, ops = [];\n                for (var i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n                    var token = format[i];\n                    var isBackSlash = token === \"\\\\\";\n                    var escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n                    if (tokenRegex[token] && !escaped) {\n                        regexStr += tokenRegex[token];\n                        var match = new RegExp(regexStr).exec(date);\n                        if (match && (matched = true)) {\n                            ops[token !== \"Y\" ? \"push\" : \"unshift\"]({\n                                fn: revFormat[token],\n                                val: match[++matchIndex],\n                            });\n                        }\n                    }\n                    else if (!isBackSlash)\n                        regexStr += \".\";\n                }\n                parsedDate =\n                    !config || !config.noCalendar\n                        ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)\n                        : new Date(new Date().setHours(0, 0, 0, 0));\n                ops.forEach(function (_a) {\n                    var fn = _a.fn, val = _a.val;\n                    return (parsedDate = fn(parsedDate, val, locale) || parsedDate);\n                });\n                parsedDate = matched ? parsedDate : undefined;\n            }\n        }\n        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {\n            config.errorHandler(new Error(\"Invalid date provided: \" + dateOrig));\n            return undefined;\n        }\n        if (timeless === true)\n            parsedDate.setHours(0, 0, 0, 0);\n        return parsedDate;\n    };\n};\nexport function compareDates(date1, date2, timeless) {\n    if (timeless === void 0) { timeless = true; }\n    if (timeless !== false) {\n        return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -\n            new Date(date2.getTime()).setHours(0, 0, 0, 0));\n    }\n    return date1.getTime() - date2.getTime();\n}\nexport function compareTimes(date1, date2) {\n    return (3600 * (date1.getHours() - date2.getHours()) +\n        60 * (date1.getMinutes() - date2.getMinutes()) +\n        date1.getSeconds() -\n        date2.getSeconds());\n}\nexport var isBetween = function (ts, ts1, ts2) {\n    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);\n};\nexport var calculateSecondsSinceMidnight = function (hours, minutes, seconds) {\n    return hours * 3600 + minutes * 60 + seconds;\n};\nexport var parseSeconds = function (secondsSinceMidnight) {\n    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;\n    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];\n};\nexport var duration = {\n    DAY: 86400000,\n};\nexport function getDefaultHours(config) {\n    var hours = config.defaultHour;\n    var minutes = config.defaultMinute;\n    var seconds = config.defaultSeconds;\n    if (config.minDate !== undefined) {\n        var minHour = config.minDate.getHours();\n        var minMinutes = config.minDate.getMinutes();\n        var minSeconds = config.minDate.getSeconds();\n        if (hours < minHour) {\n            hours = minHour;\n        }\n        if (hours === minHour && minutes < minMinutes) {\n            minutes = minMinutes;\n        }\n        if (hours === minHour && minutes === minMinutes && seconds < minSeconds)\n            seconds = config.minDate.getSeconds();\n    }\n    if (config.maxDate !== undefined) {\n        var maxHr = config.maxDate.getHours();\n        var maxMinutes = config.maxDate.getMinutes();\n        hours = Math.min(hours, maxHr);\n        if (hours === maxHr)\n            minutes = Math.min(maxMinutes, minutes);\n        if (hours === maxHr && minutes === maxMinutes)\n            seconds = config.maxDate.getSeconds();\n    }\n    return { hours: hours, minutes: minutes, seconds: seconds };\n}\n"]},"metadata":{},"sourceType":"module"}