{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nexport function cvToString(val) {\n  let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n\n    case ClarityType.BoolFalse:\n      return 'false';\n\n    case ClarityType.Int:\n      return val.value.toString();\n\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n\n      return `0x${val.buffer.toString('hex')}`;\n\n    case ClarityType.OptionalNone:\n      return 'none';\n\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${cvToString(val.data[key], encoding)})`).join(' ')})`;\n\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\nexport function cvToValue(val) {\n  let strictJsonCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n\n    case ClarityType.BoolFalse:\n      return false;\n\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      } else {\n        return val.value;\n      }\n\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n\n    case ClarityType.OptionalNone:\n      return null;\n\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n\n    case ClarityType.Tuple:\n      const result = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n\n    case ClarityType.StringASCII:\n      return val.data;\n\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\nexport function cvToJSON(val) {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: false\n      };\n\n    case ClarityType.ResponseOk:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: true\n      };\n\n    default:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true)\n      };\n  }\n}\nexport function getCVTypeString(val) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n\n    case ClarityType.Int:\n      return 'int';\n\n    case ClarityType.UInt:\n      return 'uint';\n\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n\n    case ClarityType.List:\n      return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;\n\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${getCVTypeString(val.data[key])})`).join(' ')})`;\n\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}","map":{"version":3,"sources":["../../../src/clarity/clarityValue.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nexport function cvToString(val, encoding = 'hex') {\n    switch (val.type) {\n        case ClarityType.BoolTrue:\n            return 'true';\n        case ClarityType.BoolFalse:\n            return 'false';\n        case ClarityType.Int:\n            return val.value.toString();\n        case ClarityType.UInt:\n            return `u${val.value.toString()}`;\n        case ClarityType.Buffer:\n            if (encoding === 'tryAscii') {\n                const str = val.buffer.toString('ascii');\n                if (/[ -~]/.test(str)) {\n                    return JSON.stringify(str);\n                }\n            }\n            return `0x${val.buffer.toString('hex')}`;\n        case ClarityType.OptionalNone:\n            return 'none';\n        case ClarityType.OptionalSome:\n            return `(some ${cvToString(val.value, encoding)})`;\n        case ClarityType.ResponseErr:\n            return `(err ${cvToString(val.value, encoding)})`;\n        case ClarityType.ResponseOk:\n            return `(ok ${cvToString(val.value, encoding)})`;\n        case ClarityType.PrincipalStandard:\n        case ClarityType.PrincipalContract:\n            return principalToString(val);\n        case ClarityType.List:\n            return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n        case ClarityType.Tuple:\n            return `(tuple ${Object.keys(val.data)\n                .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n                .join(' ')})`;\n        case ClarityType.StringASCII:\n            return `\"${val.data}\"`;\n        case ClarityType.StringUTF8:\n            return `u\"${val.data}\"`;\n    }\n}\nexport function cvToValue(val, strictJsonCompat = false) {\n    switch (val.type) {\n        case ClarityType.BoolTrue:\n            return true;\n        case ClarityType.BoolFalse:\n            return false;\n        case ClarityType.Int:\n        case ClarityType.UInt:\n            if (strictJsonCompat) {\n                return val.value.toString();\n            }\n            else {\n                return val.value;\n            }\n        case ClarityType.Buffer:\n            return `0x${val.buffer.toString('hex')}`;\n        case ClarityType.OptionalNone:\n            return null;\n        case ClarityType.OptionalSome:\n            return cvToJSON(val.value);\n        case ClarityType.ResponseErr:\n            return cvToJSON(val.value);\n        case ClarityType.ResponseOk:\n            return cvToJSON(val.value);\n        case ClarityType.PrincipalStandard:\n        case ClarityType.PrincipalContract:\n            return principalToString(val);\n        case ClarityType.List:\n            return val.list.map(v => cvToJSON(v));\n        case ClarityType.Tuple:\n            const result = {};\n            Object.keys(val.data).forEach(key => {\n                result[key] = cvToJSON(val.data[key]);\n            });\n            return result;\n        case ClarityType.StringASCII:\n            return val.data;\n        case ClarityType.StringUTF8:\n            return val.data;\n    }\n}\nexport function cvToJSON(val) {\n    switch (val.type) {\n        case ClarityType.ResponseErr:\n            return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n        case ClarityType.ResponseOk:\n            return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n        default:\n            return { type: getCVTypeString(val), value: cvToValue(val, true) };\n    }\n}\nexport function getCVTypeString(val) {\n    switch (val.type) {\n        case ClarityType.BoolTrue:\n        case ClarityType.BoolFalse:\n            return 'bool';\n        case ClarityType.Int:\n            return 'int';\n        case ClarityType.UInt:\n            return 'uint';\n        case ClarityType.Buffer:\n            return `(buff ${val.buffer.length})`;\n        case ClarityType.OptionalNone:\n            return '(optional none)';\n        case ClarityType.OptionalSome:\n            return `(optional ${getCVTypeString(val.value)})`;\n        case ClarityType.ResponseErr:\n            return `(response UnknownType ${getCVTypeString(val.value)})`;\n        case ClarityType.ResponseOk:\n            return `(response ${getCVTypeString(val.value)} UnknownType)`;\n        case ClarityType.PrincipalStandard:\n        case ClarityType.PrincipalContract:\n            return 'principal';\n        case ClarityType.List:\n            return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;\n        case ClarityType.Tuple:\n            return `(tuple ${Object.keys(val.data)\n                .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n                .join(' ')})`;\n        case ClarityType.StringASCII:\n            return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n        case ClarityType.StringUTF8:\n            return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n    }\n}\n//# sourceMappingURL=clarityValue.js.map"]},"metadata":{},"sourceType":"module"}