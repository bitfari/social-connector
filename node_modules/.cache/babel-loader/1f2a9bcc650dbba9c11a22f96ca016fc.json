{"ast":null,"code":"import { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { getAddressFromPublicKey } from '@stacks/transactions';\nexport function signProfileToken(profile, privateKey, subject, issuer) {\n  let signingAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ES256K';\n  let issuedAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Date();\n  let expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : nextYear();\n\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = {\n      publicKey\n    };\n  }\n\n  if (!issuer) {\n    issuer = {\n      publicKey\n    };\n  }\n\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n  const payload = {\n    jti: makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\nexport function wrapProfileToken(token) {\n  return {\n    token,\n    decodedToken: decodeToken(token)\n  };\n}\nexport function verifyProfileToken(token, publicKeyOrAddress) {\n  const decodedToken = decodeToken(token);\n  const payload = decodedToken.payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.hasOwnProperty('subject') && payload.subject) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have a subject public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have a subject\");\n  }\n\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have an issuer public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have an issuer\");\n  }\n\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error(\"Token doesn't have a claim\");\n  }\n\n  const issuerPublicKey = payload.issuer.publicKey;\n  const address = getAddressFromPublicKey(issuerPublicKey);\n\n  if (publicKeyOrAddress === issuerPublicKey) {} else if (publicKeyOrAddress === address) {} else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\nexport function extractProfile(token) {\n  let publicKeyOrAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let decodedToken;\n\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = decodeToken(token);\n  }\n\n  let profile = {};\n\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim;\n    }\n  }\n\n  return profile;\n}","map":{"version":3,"sources":["../../src/profileTokens.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { getAddressFromPublicKey } from '@stacks/transactions';\nexport function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = nextYear()) {\n    if (signingAlgorithm !== 'ES256K') {\n        throw new Error('Signing algorithm not supported');\n    }\n    const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n    if (!subject) {\n        subject = { publicKey };\n    }\n    if (!issuer) {\n        issuer = { publicKey };\n    }\n    const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n    const payload = {\n        jti: makeUUID4(),\n        iat: issuedAt.toISOString(),\n        exp: expiresAt.toISOString(),\n        subject,\n        issuer,\n        claim: profile,\n    };\n    return tokenSigner.sign(payload);\n}\nexport function wrapProfileToken(token) {\n    return {\n        token,\n        decodedToken: decodeToken(token),\n    };\n}\nexport function verifyProfileToken(token, publicKeyOrAddress) {\n    const decodedToken = decodeToken(token);\n    const payload = decodedToken.payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.hasOwnProperty('subject') && payload.subject) {\n        if (!payload.subject.hasOwnProperty('publicKey')) {\n            throw new Error(\"Token doesn't have a subject public key\");\n        }\n    }\n    else {\n        throw new Error(\"Token doesn't have a subject\");\n    }\n    if (payload.hasOwnProperty('issuer') && payload.issuer) {\n        if (!payload.issuer.hasOwnProperty('publicKey')) {\n            throw new Error(\"Token doesn't have an issuer public key\");\n        }\n    }\n    else {\n        throw new Error(\"Token doesn't have an issuer\");\n    }\n    if (!payload.hasOwnProperty('claim')) {\n        throw new Error(\"Token doesn't have a claim\");\n    }\n    const issuerPublicKey = payload.issuer.publicKey;\n    const address = getAddressFromPublicKey(issuerPublicKey);\n    if (publicKeyOrAddress === issuerPublicKey) {\n    }\n    else if (publicKeyOrAddress === address) {\n    }\n    else {\n        throw new Error('Token issuer public key does not match the verifying value');\n    }\n    const tokenVerifier = new TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n    if (!tokenVerifier) {\n        throw new Error('Invalid token verifier');\n    }\n    const tokenVerified = tokenVerifier.verify(token);\n    if (!tokenVerified) {\n        throw new Error('Token verification failed');\n    }\n    return decodedToken;\n}\nexport function extractProfile(token, publicKeyOrAddress = null) {\n    let decodedToken;\n    if (publicKeyOrAddress) {\n        decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n    }\n    else {\n        decodedToken = decodeToken(token);\n    }\n    let profile = {};\n    if (decodedToken.hasOwnProperty('payload')) {\n        const payload = decodedToken.payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        if (payload.hasOwnProperty('claim')) {\n            profile = payload.claim;\n        }\n    }\n    return profile;\n}\n//# sourceMappingURL=profileTokens.js.map"]},"metadata":{},"sourceType":"module"}