"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTxId = exports.validateStacksAddress = exports.parseReadOnlyResponse = exports.hexToCV = exports.cvToHex = exports.fetchPrivate = exports.isClarityName = exports.hashP2WSH = exports.hashP2SH = exports.hashP2WPKH = exports.hashP2PKH = exports.hash160 = exports.txidFromData = exports.sha512_256 = exports.omit = exports.cloneDeep = exports.exceedsMaxLengthBytes = exports.hexStringToInt = exports.intToHexString = exports.rightPadHexToLength = exports.leftPadHexToLength = exports.leftPadHex = exports.BufferArray = exports.randomBytes = void 0;
const common_1 = require("@stacks/common");
const sha_js_1 = require("sha.js");
const clarity_1 = require("./clarity");
const ripemd160_min_1 = __importDefault(require("ripemd160-min"));
const randombytes_1 = __importDefault(require("randombytes"));
exports.randomBytes = randombytes_1.default;
const clarity_2 = require("./clarity");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const c32check_1 = require("c32check");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const common_2 = require("@stacks/common");
class BufferArray {
    constructor() {
        this._value = [];
    }
    get value() {
        return this._value;
    }
    appendHexString(hexString) {
        this.value.push(common_1.Buffer.from(hexString, 'hex'));
    }
    push(buffer) {
        return this._value.push(buffer);
    }
    appendByte(octet) {
        if (!Number.isInteger(octet) || octet < 0 || octet > 255) {
            throw new Error(`Value ${octet} is not a valid byte`);
        }
        this.value.push(common_1.Buffer.from([octet]));
    }
    concatBuffer() {
        return common_1.Buffer.concat(this.value);
    }
}
exports.BufferArray = BufferArray;
const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
exports.leftPadHex = leftPadHex;
const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
exports.leftPadHexToLength = leftPadHexToLength;
const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
exports.rightPadHexToLength = rightPadHexToLength;
const intToHexString = (integer, lengthBytes = 8) => integer.toString(16).padStart(lengthBytes * 2, '0');
exports.intToHexString = intToHexString;
const hexStringToInt = (hexString) => parseInt(hexString, 16);
exports.hexStringToInt = hexStringToInt;
const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? common_1.Buffer.from(string).length > maxLengthBytes : false;
exports.exceedsMaxLengthBytes = exceedsMaxLengthBytes;
function cloneDeep(obj) {
    return lodash_clonedeep_1.default(obj);
}
exports.cloneDeep = cloneDeep;
function omit(obj, prop) {
    const clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
}
exports.omit = omit;
class sha512_256 extends sha_js_1.sha512 {
    constructor() {
        super();
        Object.assign(this, {
            _ah: 0x22312194,
            _al: 0xfc2bf72c,
            _bh: 0x9f555fa3,
            _bl: 0xc84c64c2,
            _ch: 0x2393b86b,
            _cl: 0x6f53b151,
            _dh: 0x96387719,
            _dl: 0x5940eabd,
            _eh: 0x96283ee2,
            _el: 0xa88effe3,
            _fh: 0xbe5e1e25,
            _fl: 0x53863992,
            _gh: 0x2b0199fc,
            _gl: 0x2c85b8aa,
            _hh: 0x0eb72ddc,
            _hl: 0x81c52ca2,
        });
    }
    digest(encoding) {
        const buff = super.digest().slice(0, 32);
        return encoding ? buff.toString(encoding) : buff;
    }
}
exports.sha512_256 = sha512_256;
const txidFromData = (data) => new sha512_256().update(data).digest('hex');
exports.txidFromData = txidFromData;
const hash160 = (input) => {
    const sha256Result = new sha_js_1.sha256().update(input).digest();
    return common_1.Buffer.from(new ripemd160_min_1.default().update(sha256Result).digest());
};
exports.hash160 = hash160;
const hashP2PKH = (input) => {
    return exports.hash160(input).toString('hex');
};
exports.hashP2PKH = hashP2PKH;
const hashP2WPKH = (input) => {
    const keyHash = exports.hash160(input);
    const bufferArray = new BufferArray();
    bufferArray.appendByte(0);
    bufferArray.appendByte(keyHash.length);
    bufferArray.push(keyHash);
    const redeemScript = bufferArray.concatBuffer();
    const redeemScriptHash = exports.hash160(redeemScript);
    return redeemScriptHash.toString('hex');
};
exports.hashP2WPKH = hashP2WPKH;
const hashP2SH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2SH multisig address can only contain up to 15 public keys');
    }
    const bufferArray = new BufferArray();
    bufferArray.appendByte(80 + numSigs);
    pubKeys.forEach(pubKey => {
        bufferArray.appendByte(pubKey.length);
        bufferArray.push(pubKey);
    });
    bufferArray.appendByte(80 + pubKeys.length);
    bufferArray.appendByte(174);
    const redeemScript = bufferArray.concatBuffer();
    const redeemScriptHash = exports.hash160(redeemScript);
    return redeemScriptHash.toString('hex');
};
exports.hashP2SH = hashP2SH;
const hashP2WSH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2WSH multisig address can only contain up to 15 public keys');
    }
    const scriptArray = new BufferArray();
    scriptArray.appendByte(80 + numSigs);
    pubKeys.forEach(pubKey => {
        scriptArray.appendByte(pubKey.length);
        scriptArray.push(pubKey);
    });
    scriptArray.appendByte(80 + pubKeys.length);
    scriptArray.appendByte(174);
    const script = scriptArray.concatBuffer();
    const digest = new sha_js_1.sha256().update(script).digest();
    const bufferArray = new BufferArray();
    bufferArray.appendByte(0);
    bufferArray.appendByte(digest.length);
    bufferArray.push(digest);
    const redeemScript = bufferArray.concatBuffer();
    const redeemScriptHash = exports.hash160(redeemScript);
    return redeemScriptHash.toString('hex');
};
exports.hashP2WSH = hashP2WSH;
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
exports.isClarityName = isClarityName;
async function fetchPrivate(input, init) {
    const defaultFetchOpts = {
        referrer: 'no-referrer',
        referrerPolicy: 'no-referrer',
    };
    const fetchOpts = Object.assign(defaultFetchOpts, init);
    const fetchResult = await cross_fetch_1.default(input, fetchOpts);
    return fetchResult;
}
exports.fetchPrivate = fetchPrivate;
function cvToHex(cv) {
    const serialized = clarity_1.serializeCV(cv);
    return `0x${serialized.toString('hex')}`;
}
exports.cvToHex = cvToHex;
function hexToCV(hex) {
    return clarity_2.deserializeCV(hex);
}
exports.hexToCV = hexToCV;
const parseReadOnlyResponse = (response) => {
    if (response.okay) {
        return hexToCV(response.result);
    }
    else {
        throw new Error(response.cause);
    }
};
exports.parseReadOnlyResponse = parseReadOnlyResponse;
const validateStacksAddress = (stacksAddress) => {
    try {
        c32check_1.c32addressDecode(stacksAddress);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.validateStacksAddress = validateStacksAddress;
const validateTxId = (txid) => {
    if (txid === 'success')
        return true;
    const value = common_2.with0x(txid).toLowerCase();
    if (value.length !== 66)
        return false;
    return common_2.with0x(BigInt(value).toString(16).padStart(64, '0')) === value;
};
exports.validateTxId = validateTxId;
//# sourceMappingURL=utils.js.map