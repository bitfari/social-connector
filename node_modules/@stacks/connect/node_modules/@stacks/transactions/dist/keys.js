"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publicKeyToAddress = exports.privateKeyToString = exports.getPublicKey = exports.parseRecoverableSignature = exports.getSignatureRecoveryParam = exports.signWithKey = exports.makeRandomPrivKey = exports.createStacksPrivateKey = exports.deserializePublicKey = exports.compressPublicKey = exports.pubKeyfromPrivKey = exports.serializePublicKey = exports.publicKeyToString = exports.isCompressed = exports.publicKeyFromBuffer = exports.publicKeyFromSignature = exports.createStacksPublicKey = exports.getAddressFromPublicKey = exports.getAddressFromPrivateKey = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const elliptic_1 = require("elliptic");
const authorization_1 = require("./authorization");
const c32check_1 = require("c32check");
const types_1 = require("./types");
function getAddressFromPrivateKey(privateKey, transactionVersion = constants_1.TransactionVersion.Mainnet) {
    const pubKey = pubKeyfromPrivKey(privateKey);
    return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
function getAddressFromPublicKey(publicKey, transactionVersion = constants_1.TransactionVersion.Mainnet) {
    publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');
    const addrVer = (0, types_1.addressHashModeToVersion)(constants_1.AddressHashMode.SerializeP2PKH, transactionVersion);
    const addr = (0, types_1.addressFromVersionHash)(addrVer, (0, utils_1.hashP2PKH)(common_1.Buffer.from(publicKey, 'hex')));
    const addrString = (0, types_1.addressToString)(addr);
    return addrString;
}
exports.getAddressFromPublicKey = getAddressFromPublicKey;
function createStacksPublicKey(key) {
    return {
        type: constants_1.StacksMessageType.PublicKey,
        data: common_1.Buffer.from(key, 'hex'),
    };
}
exports.createStacksPublicKey = createStacksPublicKey;
function publicKeyFromSignature(message, messageSignature, pubKeyEncoding = constants_1.PubKeyEncoding.Compressed) {
    const ec = new elliptic_1.ec('secp256k1');
    const messageBN = ec.keyFromPrivate(message, 'hex').getPrivate().toString(10);
    const parsedSignature = parseRecoverableSignature(messageSignature.data);
    const publicKey = ec.recoverPubKey(messageBN, parsedSignature, parsedSignature.recoveryParam, 'hex');
    if (pubKeyEncoding == constants_1.PubKeyEncoding.Uncompressed) {
        return publicKey.encode('hex');
    }
    return publicKey.encodeCompressed('hex');
}
exports.publicKeyFromSignature = publicKeyFromSignature;
function publicKeyFromBuffer(data) {
    return { type: constants_1.StacksMessageType.PublicKey, data };
}
exports.publicKeyFromBuffer = publicKeyFromBuffer;
function isCompressed(key) {
    return !key.data.toString('hex').startsWith('04');
}
exports.isCompressed = isCompressed;
function publicKeyToString(key) {
    return key.data.toString('hex');
}
exports.publicKeyToString = publicKeyToString;
function serializePublicKey(key) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.push(key.data);
    return bufferArray.concatBuffer();
}
exports.serializePublicKey = serializePublicKey;
function pubKeyfromPrivKey(privateKey) {
    const privKey = createStacksPrivateKey(privateKey);
    const ec = new elliptic_1.ec('secp256k1');
    const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');
    const pubKey = keyPair.getPublic(privKey.compressed, 'hex');
    return createStacksPublicKey(pubKey);
}
exports.pubKeyfromPrivKey = pubKeyfromPrivKey;
function compressPublicKey(publicKey) {
    const ec = new elliptic_1.ec('secp256k1');
    const key = ec.keyFromPublic(publicKey);
    const pubKey = key.getPublic(true, 'hex');
    return createStacksPublicKey(pubKey);
}
exports.compressPublicKey = compressPublicKey;
function deserializePublicKey(bufferReader) {
    const fieldId = bufferReader.readUInt8();
    const keyLength = fieldId !== 4 ? constants_1.COMPRESSED_PUBKEY_LENGTH_BYTES : constants_1.UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBuffer(common_1.Buffer.concat([common_1.Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));
}
exports.deserializePublicKey = deserializePublicKey;
function createStacksPrivateKey(key) {
    const data = typeof key === 'string' ? common_1.Buffer.from(key, 'hex') : key;
    let compressed;
    if (data.length === 33) {
        if (data[data.length - 1] !== 1) {
            throw new Error('Improperly formatted private-key. 33 byte length usually ' +
                'indicates compressed key, but last byte must be == 0x01');
        }
        compressed = true;
    }
    else if (data.length === 32) {
        compressed = false;
    }
    else {
        throw new Error(`Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`);
    }
    return { data, compressed };
}
exports.createStacksPrivateKey = createStacksPrivateKey;
function makeRandomPrivKey(entropy) {
    const ec = new elliptic_1.ec('secp256k1');
    const options = { entropy: entropy || (0, utils_1.randomBytes)(32) };
    const keyPair = ec.genKeyPair(options);
    const privateKey = keyPair.getPrivate().toString('hex', 32);
    return createStacksPrivateKey(privateKey);
}
exports.makeRandomPrivKey = makeRandomPrivKey;
function signWithKey(privateKey, input) {
    const ec = new elliptic_1.ec('secp256k1');
    const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');
    const signature = key.sign(input, 'hex', { canonical: true });
    const coordinateValueBytes = 32;
    const r = (0, utils_1.leftPadHexToLength)(signature.r.toString('hex'), coordinateValueBytes * 2);
    const s = (0, utils_1.leftPadHexToLength)(signature.s.toString('hex'), coordinateValueBytes * 2);
    if (signature.recoveryParam === undefined || signature.recoveryParam === null) {
        throw new Error('"signature.recoveryParam" is not set');
    }
    const recoveryParam = (0, utils_1.intToHexString)(signature.recoveryParam, 1);
    const recoverableSignatureString = recoveryParam + r + s;
    return (0, authorization_1.createMessageSignature)(recoverableSignatureString);
}
exports.signWithKey = signWithKey;
function getSignatureRecoveryParam(signature) {
    const coordinateValueBytes = 32;
    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
        throw new Error('Invalid signature');
    }
    const recoveryParamHex = signature.substr(0, 2);
    return (0, utils_1.hexStringToInt)(recoveryParamHex);
}
exports.getSignatureRecoveryParam = getSignatureRecoveryParam;
function parseRecoverableSignature(signature) {
    const coordinateValueBytes = 32;
    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
        throw new Error('Invalid signature');
    }
    const recoveryParamHex = signature.substr(0, 2);
    const r = signature.substr(2, coordinateValueBytes * 2);
    const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);
    return {
        recoveryParam: (0, utils_1.hexStringToInt)(recoveryParamHex),
        r,
        s,
    };
}
exports.parseRecoverableSignature = parseRecoverableSignature;
function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data);
}
exports.getPublicKey = getPublicKey;
function privateKeyToString(privateKey) {
    return privateKey.data.toString('hex');
}
exports.privateKeyToString = privateKeyToString;
function publicKeyToAddress(version, publicKey) {
    return (0, c32check_1.c32address)(version, (0, utils_1.hash160)(publicKey.data).toString('hex'));
}
exports.publicKeyToAddress = publicKeyToAddress;
//# sourceMappingURL=keys.js.map