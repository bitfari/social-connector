"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializePostCondition = exports.serializePostCondition = exports.createNonFungiblePostCondition = exports.createFungiblePostCondition = exports.createSTXPostCondition = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const types_1 = require("./types");
const clarity_1 = require("./clarity");
const errors_1 = require("./errors");
function createSTXPostCondition(principal, conditionCode, amount) {
    if (typeof principal === 'string') {
        principal = (0, types_1.parsePrincipalString)(principal);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.STX,
        principal,
        conditionCode,
        amount: (0, common_1.intToBigInt)(amount, false),
    };
}
exports.createSTXPostCondition = createSTXPostCondition;
function createFungiblePostCondition(principal, conditionCode, amount, assetInfo) {
    if (typeof principal === 'string') {
        principal = (0, types_1.parsePrincipalString)(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = (0, types_1.parseAssetInfoString)(assetInfo);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.Fungible,
        principal,
        conditionCode,
        amount: (0, common_1.intToBigInt)(amount, false),
        assetInfo,
    };
}
exports.createFungiblePostCondition = createFungiblePostCondition;
function createNonFungiblePostCondition(principal, conditionCode, assetInfo, assetName) {
    if (typeof principal === 'string') {
        principal = (0, types_1.parsePrincipalString)(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = (0, types_1.parseAssetInfoString)(assetInfo);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.NonFungible,
        principal,
        conditionCode,
        assetInfo,
        assetName,
    };
}
exports.createNonFungiblePostCondition = createNonFungiblePostCondition;
function serializePostCondition(postCondition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(postCondition.conditionType);
    bufferArray.push((0, types_1.serializePrincipal)(postCondition.principal));
    if (postCondition.conditionType === constants_1.PostConditionType.Fungible ||
        postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bufferArray.push((0, types_1.serializeAssetInfo)(postCondition.assetInfo));
    }
    if (postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bufferArray.push((0, clarity_1.serializeCV)(postCondition.assetName));
    }
    bufferArray.appendByte(postCondition.conditionCode);
    if (postCondition.conditionType === constants_1.PostConditionType.STX ||
        postCondition.conditionType === constants_1.PostConditionType.Fungible) {
        bufferArray.push((0, common_1.intToBytes)(postCondition.amount, false, 8));
    }
    return bufferArray.concatBuffer();
}
exports.serializePostCondition = serializePostCondition;
function deserializePostCondition(bufferReader) {
    const postConditionType = bufferReader.readUInt8Enum(constants_1.PostConditionType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as PostConditionType`);
    });
    const principal = (0, types_1.deserializePrincipal)(bufferReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case constants_1.PostConditionType.STX:
            conditionCode = bufferReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case constants_1.PostConditionType.Fungible:
            assetInfo = (0, types_1.deserializeAssetInfo)(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case constants_1.PostConditionType.NonFungible:
            assetInfo = (0, types_1.deserializeAssetInfo)(bufferReader);
            const assetName = (0, clarity_1.deserializeCV)(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(constants_1.NonFungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}
exports.deserializePostCondition = deserializePostCondition;
//# sourceMappingURL=postcondition.js.map