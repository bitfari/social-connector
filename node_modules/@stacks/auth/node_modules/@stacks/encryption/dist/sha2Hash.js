"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashSha512Sync = exports.hashSha256Sync = exports.createSha2Hash = exports.WebCryptoSha2Hash = exports.NodeCryptoSha2Hash = void 0;
const common_1 = require("@stacks/common");
const sha_js_1 = require("sha.js");
const cryptoUtils_1 = require("./cryptoUtils");
class NodeCryptoSha2Hash {
    constructor(createHash) {
        this.createHash = createHash;
    }
    async digest(data, algorithm = 'sha256') {
        try {
            const result = this.createHash(algorithm).update(data).digest();
            return Promise.resolve(result);
        }
        catch (error) {
            console.log(error);
            console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);
            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
        }
    }
}
exports.NodeCryptoSha2Hash = NodeCryptoSha2Hash;
class WebCryptoSha2Hash {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async digest(data, algorithm = 'sha256') {
        let algo;
        if (algorithm === 'sha256') {
            algo = 'SHA-256';
        }
        else if (algorithm === 'sha512') {
            algo = 'SHA-512';
        }
        else {
            throw new Error(`Unsupported hash algorithm ${algorithm}`);
        }
        try {
            const hash = await this.subtleCrypto.digest(algo, data);
            return common_1.Buffer.from(hash);
        }
        catch (error) {
            console.log(error);
            console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);
            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
        }
    }
}
exports.WebCryptoSha2Hash = WebCryptoSha2Hash;
async function createSha2Hash() {
    const cryptoLib = await cryptoUtils_1.getCryptoLib();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoSha2Hash(cryptoLib.lib);
    }
    else {
        return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);
    }
}
exports.createSha2Hash = createSha2Hash;
function hashSha256Sync(data) {
    const hash = new sha_js_1.sha256();
    hash.update(data);
    return hash.digest();
}
exports.hashSha256Sync = hashSha256Sync;
function hashSha512Sync(data) {
    const hash = new sha_js_1.sha512();
    hash.update(data);
    return hash.digest();
}
exports.hashSha512Sync = hashSha512Sync;
//# sourceMappingURL=sha2Hash.js.map