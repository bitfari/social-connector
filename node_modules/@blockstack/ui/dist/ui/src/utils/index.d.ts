import React from 'react';
export declare function getWindow(node?: HTMLElement | null): Window | undefined;
export declare const isBrowser: boolean;
export declare function isFunction(value: any): value is Function;
export interface CreateContextOptions {
    strict?: boolean;
    errorMessage?: string;
    name?: string;
}
declare type CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>];
export declare function createContext<ContextType>(options?: CreateContextOptions): CreateContextReturn<ContextType>;
export declare function getValidChildren(children: React.ReactNode): React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)>[];
declare type ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>;
export declare function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T): void;
export declare function mergeRefs<T>(...refs: (ReactRef<T> | undefined)[]): (value: T) => void;
export declare function genId(prefix: string): string;
export declare const makeId: (id: string, index: number) => string;
export declare function getFocusables(element: HTMLElement, keyboardOnly?: boolean): Element[];
export declare const getColorInTheme: (theme: any, color: string) => any;
export declare const __DEV__: boolean;
export declare function runIfFn<T, U>(valueOrFn: T | ((...args: U[]) => T), ...args: U[]): T;
export declare function warn(options: {
    condition: boolean;
    message: string;
}): void;
export declare function error(options: {
    condition: boolean;
    message: string;
}): void;
export declare type FunctionArguments<T extends Function> = T extends (...args: infer R) => any ? R : never;
export declare function callAllHandlers<T extends (event: any) => void>(...fns: (T | undefined)[]): (event: FunctionArguments<T>[0]) => void;
export declare type Merge<T1, T2> = Omit<T1, Extract<keyof T1, keyof T2>> & T2;
export declare type SafeMerge<T, P> = P & Omit<T, keyof P>;
export declare type UnionStringArray<T extends Readonly<string[]>> = T[number];
export declare type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
export declare type As<P = any> = React.ReactType<P>;
export declare type AnyFunction<T = any> = (...args: T[]) => any;
export declare type Dict<T = any> = Record<string, T>;
export declare type ReactNodeOrRenderProp<P> = React.ReactNode | ((props: P) => React.ReactNode);
export declare type Booleanish = boolean | 'true' | 'false';
export declare type ObjectOrArray<T, K extends keyof any = keyof any> = T[] | Record<K, T>;
export declare type StringOrNumber = string | number;
export declare function isNumber(value: any): value is number;
export declare const isNotNumber: (value: any) => boolean;
export declare function isNumeric(value: any): boolean;
export declare function isArray<T>(value: any): value is T[];
export declare const isEmptyArray: (value: any) => boolean;
export declare const isDefined: (value: any) => boolean;
export declare const isUndefined: (value: any) => value is undefined;
export declare const isObject: (value: any) => value is Record<string, any>;
export declare const isEmptyObject: (value: any) => boolean;
export declare const isNull: (value: any) => value is null;
export declare function isString(value: any): value is string;
export declare const isEmpty: (value: any) => boolean;
export declare function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]): Pick<T, Exclude<keyof T, K>>;
export declare function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]): { [P in K]: T[P]; };
export declare function split<T extends Dict, K extends keyof T>(object: T, keys: K[]): [{ [P in K]: T[P]; }, Pick<T, Exclude<keyof T, K>>];
export declare function get(obj: any, path: string | number, fallback?: any, index?: number): any;
export declare function getWithDefault(path: any, scale: any): any;
export declare function mapResponsive(prop: any, mapper: (val: any) => any): any;
export declare const startPad: (n: number, z?: number, s?: string) => string;
export {};
